<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端面试题准备]]></title>
    <url>%2F2020%2F03%2F18%2Finterview-question-archive%2F</url>
    <content type="text"><![CDATA[[TOC] 面试问题整理计算机网络OSI七层模型应用层 ：为应用程序提供服务，并管理应用程序之间的通信（SMTP、HTTP、FTP）表示层 ：处理数据的标识问题，比如编码、格式转化、加密解密等会话层 ：负责建立管理和断开通信连接，实现数据同步传输层 ：端到端传输数据，同时处理传输错误、控制流量等（TCP UDP）网络层 ：地址管理、路由选择（IP协议）数据链路层 ：数据分割成帧，mac寻址、差错校验、信息纠正等。（以太网）物理层 ：利用传输介质为数据链路层提供物理连接 发送端从应用层 → 物理层 打包发送接收层从物理层 → 应用层 解析获取 路由器工作在哪一层网络层。 路由器是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，先后顺序发送信号。 路由和交换机最主要的区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层（网络层）。 这一区别决定了路由和交换机在移动信息的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。 DNS解析过程 根DNS服务器：返回顶级域名 DNS 服务器的 IP 地址 顶级域DNS服务器：返回权威域名 DNS 服务器的 IP 地址 权威DNS服务器：返回相应主机的 IP 地址 以输入 www.google.com 为例，1.浏览器检查自身缓存，有无解析此域名对应的ip2.操作系统缓存hosts文件中查询3.没有的话，请求本地域名服务器（LDNS）解析域名（一般在城市某处，距离不会太远）4.如果还没有的话，就去根DNS域服务器查询，此时会给出.com的顶级域名服务器5.然后去.com服务器查询，此时会给出这个域名google.com的地址，这是网站注册的域名服务器6.去NameServer查询，根据映射关系表找到目标IP,返回给LDNS（LDNS缓存域名及IP）7.LDNS解析结果返回用户（缓存到系统缓存中），域名解析结束 TCP与UDPUDP 与 TCP 的区别是什么？UDP 协议 是面向无连接的，不需要在正式传递数据之前先连接起双方。 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。一般可以用于直播、即时通讯、即时游戏等。 TCP 无论是建立连接还是断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。 TCP建立连接–三次握手￼起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。第一次握手客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。第二次握手服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。第三次握手当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。 TCP断开连接–四次握手TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。第一次握手若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。第二次握手B收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。第三次握手B如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。第四次握手A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。 为什么客户端 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。 TCP如何解决数据丢包或报文顺序不对的问题？TCP有ARQ超时重传机制。 一种是停止等待ARQ。比如说A向B发送一个报文，同时启动定时器，如果超时就重新发送。B如果收到相同序号的报文就会丢弃重新应答。A接受相同序号应答也丢弃。这种是单个单个传的，效率就比较低，但也不会有那种多个丢包的情况。 另一种，高效一点，连续ARQ。它用的窗口，A持续发这个窗口内的数据，B累积确认，收到多个后统一应答A，ack标志告诉A，这个序号之前的数据已经收到了。但是如果A收到3个重复的ack，那就说明有失序或丢包的情况，就会启用快速重传/快速恢复。快速重传TCP taho ，阈值设为当前窗口一半，窗口设为1开始慢开始，重新传送。快速恢复TCP Remo，机制是窗口减半，阈值为当前窗口，启用拥堵避免。不过，它是重发接收端要的包，接受收到一个Ack就退出，如果丢了很多个包就尬住再3ack触发一遍。因此快恢复进行了优化——TCP New Reno。它是区别在于它记下了这个发送段的最大序号，并且每次都比对。比如说1-10，丢包丢了4，7。最大序号就是10。接受方发的ack包是4，发送方发4，接受方收到4，发7。那么发送方就会对比7和10，知道是丢了多个包，发7。接受方收到，发11，发送方收到11后，对比10，比10大就退出快恢复阶段了。 TCP如何实现流量控制的通过滑动窗口和拥堵窗口实现的。滑动窗口主要是用于接收方，保证接收方能够接受数据。接收方通过报文告知发送方当前接收窗口剩余大小，发送窗口根据该值变化大小滑动窗口（待发送区）发送报文。拥堵窗口，主要用于网络，防止过多的数据拥堵网络，避免负载过大的情况。 Http协议HTTP（HyperText Transfer Protocol）即超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则，它是万维网交换信息的基础，它允许将HTML（超文本标记语言）文档从Web服务器传送到Web浏览器。 HTTP协议目前最新版的版本是1.1，HTTP是一种无状态的协议，无状态是指Web浏览器与Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP工作原理：HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项：HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。HTTP请求与响应HTTP遵循请求（Request）/应答（Response）模型，Web浏览器向Web服务器发送请求时，Web服务器处理请求并返回适当的应答。 HTTP请求：POST /test.php HTTP/1.1 //请求行HOST：www.test.com //请求头User-Agent：Mozilla/5.0 （windows NT 6.1；rv：15.0）Gecko/20100101 Firefox/15.0 //空白行，代表请求头结束Username=admin&amp;password=admin //请求正文1234HTTP请求包括三部分，分别是请求行（请求方法）、请求头（消息报头）和请求正文。 HTTP请求第一行为请求行，由三部分组成，第一部分说明了该请求时POST请求，第二部分是一个斜杠（/login.php），用来说明请求是该域名根目录下的login.php，第三部分说明使用的是HTTP1.1版本。 HTTP请求第二行至空白行为请求头（也被称为消息头）。其中，HOST代表请求主机地址，User-Agent代表浏览器的标识，请求头由客户端自行设定。 Post和Get有什么区别？从用法上说，Post一般用于无副作用、幂等的场景；Post多用于有副作用、不幂等的情况。 冥等的定义：发送M和N次请求，服务器上资源状态一致。比如说，注册10个账号和11个账号是不冥等的，对文章进行了10次11次修改是幂等的，因为前者多了一个账号（资源），后者是更新同一个资源。 副作用的定义：副作用是指对服务器上资源做改变。比如搜索是无副作用的，但更新是有副作用的。 从本质上说，Post和Get都取决于http，使用哪个方法与应用层传输没有必然的联系。HTTP没有要求，如果是POST，数据就要放在BODY中。也没有要求GET，数据（参数）就一定要放在URL中而不能放在BODY中。 细节上有一些区别： Get能请求缓存，但是Post不可以Post支持更多编码类型Get回退无害，Post会再次提交Get能被保存为书签，Post不可以由于浏览器Url有限制，所以Get的长度受限，但Post不受限（因为都在Body里） Http常用首部 通用 cache-control ： 控制缓存行为 connection ： 连接的性质，比如keep-alive user-Agent ：用户信息 Date ：报文创建时间 请求 Referrer Policy : 表示来源的（浏览器所访问的前一个页面）,可以用于辅助检测crsf攻击，一般浏览器的默认值是no-referrer-when-downgrade，意思是https降级http的时候不传原地址。 Accept : 能正确接收的媒体类型 Accept-XX(Accept-Charset/Accept-Encoding/Accept-Language):能正确接收的xx Expect :期待服务端的指定行文 If-Match :两端资源标记比较 If-Modified-Since : 比较时间 未修改返回304 Not Modified If-None-Match :比较标记 未修改返回304 Not Modified 响应 Location : 重定向到某个location Server : 服务器名字 Age :响应存在时间 Accept-Ranges ：可以接受的范围类型 http请求中connection=keep-alive的意义在哪里HTTP 是基于 TCP 的，每一个 HTTP 请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0 中出现了Connection: keep-alive，用于建立长连接。Keep-Alive 模式更加高效，因为避免了连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。 http请求中cache-control有哪些参数可以设置Public :表示任何缓存都可以缓存响应 private :表示响应仅供单个用户使用，不得由共享高速缓存存储。私有缓存可以存储响应。 no-cache : 强制缓存在发布缓存副本之前将请求提交到源服务器以进行验证。 no-store: 缓存不应存储有关客户端请求或服务器响应的任何内容。 状态码1xx：通知 100 客户端重新发起请求 101 更换协议 2xx：成功 200 请求成功 201create 按照客户端请求创建一个新的资源 202Accept 请求无法或不被及时处理 204No Content 请求成功，但是报文不含实体的主体部分 205Reset Content 客户端充值内容 206Partial Content 进行范围请求 3xx：重定向 301 Move Permanently 永久重定向，资源被分配到新的URL 302 Found 临时重定向 303 See Other，表示资源存在另一个URL 304 Not Modified 允许访问资源，和缓存有关 307 Temporary Redirect 临时重定向 4xx：客户端错误 400 请求报文的语法错误 401 没有权限 403 Forbidden 资源存在但被拒绝访问 404 找不到请求的资源 405 Method Not Allowed 不支持的请求方法，比如只支持 Get 5xx：服务器错误 500 服务器内部错误，异常 501 不支持请求的方法 502 Bad Gateway 代理服务器发生问题 503 Server Unavailable 服务器暂时处于超负荷状态 GET/POST 区别1、从浏览器的角度GET： “读取”一个资源，比如GET到一个html文件 GET因为是读取，就可以对GET请求的数据做缓存，参数保留在浏览器历史中。 对数据长度、数据类型的限制 在 URL 中对所有人都是可见的 用于获取信息，是无副作用的，是幂等的，且可缓存 POST： 用于修改服务器上的数据，有副作用，非幂等，不可缓存 数据不会显示在URL中 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 2、从协议的角度 GET 和 POST 是HTTP协议上的两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。 GET 方法的参数应该在 url 中，POST 方法参数应该放在 body 中 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）； POST 的提交数据方式 application/x-www-form-urlencoded，原生的&lt;form&gt;提交的数据按照key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 multipart/form-data，表单上传文件时的提交方式 application/json，告诉服务端消息主体是序列化后的 JSON 字符串 text/xml，传输 XML 格式的数据 http/httpsHTTP 缺省工作在TCP协议80端口，用户访问网站http:// 打头的都是标准HTTP服务，HTTP所封装的信息是明文的，通过抓包工具可以分析其信息内容，如果这些信息包含有你的银行卡帐号、密码，你肯定无法接受这种服务，那有没有可以加密这些敏感信息的服务呢？那就是HTTPS！ HTTPS缺省工作在TCP协议443端口，它的工作流程一般如以下方式:1) 完成TCP三次同步握手2) 客户端验证服务器数字证书，通过，进入步骤33) DH算 法协商对称加密算法的密钥、hash算法的密钥4) SSL 安全加密隧道协商完成5)网页以加密的方式传输，用协商的对称加密算法和密钥加密,保证数据机密性;用协商的hash算法进行数据完整性保护，保证数据不被篡改如果HTTPS是网银服务，以上SSL安全隧道成功建立才会要求用户输入账户信息，账户信息是在安全隧道里传输，所以不会泄密! 三次握手 HTTP 1.1 请求方法 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 HTTP 2.01、新的二进制格数数据，请求分为：Length、Type、Flag、Stream、Playload2、多路复用 (Multiplexing)，允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。3、首部压缩（Header Compression）4、服务端推送 HTTP 请求头123456789101112131415161718192021Accept: text/html,image/* -- 浏览器接受的数据类型Accept-Charset: ISO-8859-1 -- 浏览器接受的编码格式Accept-Encoding: gzip,compress --浏览器接受的数据压缩格式Accept-Language: en-us,zh- --浏览器接受的语言Host: www.it315.org:80 --（必须的）当前请求访问的目标地址（主机:端口）If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT --浏览器最后的缓存时间Referer: http://www.it315.org/index.jsp -- 当前请求来自于哪里User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) --浏览器类型Cookie:name=eric -- 浏览器保存的cookie信息Connection: close/Keep-Alive -- 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。Date: Tue, 11 Jul 2000 18:23:51 GMT -- 请求发出的时间 TCP与UDP区别1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 对称加密和非对称加密的区别对称加密是服务器和客户端加密和解密使用同一把密钥，DES算法。非对称加密是客户端会向服务端请求一个公钥，使用公钥对服务器加密后，服务器会使用私钥对数据进行解密，RSA 算法。 对称加密优缺点：对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。 非对称加密优缺点：安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 浏览器的地址栏输入URL并按下回车的过程1、浏览器的地址栏输入URL并按下回车。2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。4、根据IP建立TCP连接（三次握手）。5、HTTP发起请求。6、服务器处理请求，浏览器接收HTTP响应。7、渲染页面，构建DOM树。8、关闭TCP连接（四次挥手）。 跨域问题如何解决当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 DOM 具有同源策略，即禁止对不同源页面DOM进行操作。 前台解决前台使用 jsonp 解决，JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。 核心思想：网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 1234567891011&lt;script src="http://test.com/data.php?callback=dosomething"&gt;&lt;/script&gt;// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字 // 处理服务器返回回调函数的数据&lt;script type="text/javascript"&gt; function dosomething(res)&#123; // 处理获得的数据 console.log(res.data) &#125;&lt;/script&gt; 【1】设置document.domain解决无法读取非同源网页的 Cookie 问题 因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。） 【2】跨文档通信 API：window.postMessage() 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 CORSCORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。 1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin 【服务端设置】 服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 2、带cookie跨域请求：前后端都需要进行设置 xhr.withCredentials = true; 123456789$.ajax(&#123; url: 'http://www.test.com:8080/login', type: 'get', data: &#123;&#125;, xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie&#125;); 服务器端服务器端可以设置 Access-Control-Allow-Origin，使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。 还可以使用 Ngnix 代理，配置之后就不需要前端做什么修改了，一般我们在前后端分离项目中开发阶段会采用这种方式 浏览器缓存阅读这篇博客，总结的非常好。 强制缓存 强缓存生效时的区别在于新标签打开为from disk cache，而当前页刷新派生资源是from memory cache。 协商缓存 cookie，session和localStorage，sessionStorage的区别cookie 和 sessioncookie机制：如果不在浏览器中设置过期事件，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称为会话cookie。如果在浏览器中设置了cookie的过期事件，cookie会被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失。cookie是服务端发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。 session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持cookie时，url不做任何处理；当浏览器不支持cookie的时候，将会重写 URL 将sessionid拼接到访问地址后。 cookie保存在浏览器端，session保存在服务器端；单个cookie保存的数据不能超过4kb；session大小没有限制。session大小没有限制；cookie只能保存字符串类型，以文本的方式。session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象（session中可含有多个对象）。 localStorage和sessionStorage的区别localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。sessionStorage的生命周期是仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 请求头的Cache-control 字段Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so…基本上和它说886） 扫码登录原理以淘宝为例，当点击扫码登录时，网页首先会请求二维码服务器，生成一张二维码。请求与响应如下图： 12// 响应(function()&#123;jsonp31(&#123;"success":true,"message":"null","url":"//img.alicdn.com/imgextra/O1CN01f1PcX71rdZwYau2rM_!!5654-2-xcode.png","lgToken":"ca0cc7172af3df24af63ee6ffa30ffca","adToken":"aea482731a37b083002fd48d4089ed90"&#125;);&#125;)(); 可以看到，响应返回了二维码的URL，以及一个重要的参数lgToken，这是是网页的唯一ID。 这时，网页开始不断的轮询，判断用户是否扫码登录，每次的请求轮询都会将lgToken带上。 轮询的请求参数如下： 响应回来的是一段 jsonp 代码： 12// 轮询响应(function()&#123;jsonp742(&#123;"code":"10000","message":"login start state","success":true&#125;);&#125;)(); 当轮询时发现二维码过期时，则轮询停止。响应的 code 为 10004，message 为 QRCode expired!code=1, msg=data not exist 12// 二维码过期响应(function()&#123;jsonp2683(&#123;"code":"10004","message":"QRCode expired!code=1, msg=data not exist","success":true&#125;);&#125;)(); 点击刷新二维码，网页会再次请求二维码接口，生成新的二维码，并再次开启轮询。 当用户使用手机扫描二维码后，响应 code 变为10001，并提示扫描成功。 当用户在手机上点击确认登录时，会将用户信息以及二维码上的信息传到服务器并重新生成令牌token。当网页端再次轮询请求接口时，就返回真正的登陆态Token,网页端此时就可以凭着这个Token来登陆了。 轮询和长轮询polling即轮询，是指浏览器通过周期性轮询，查看服务器是否有更新的信息； long polling指的是长轮询，浏览器与服务器建立连接之后，服务器将此连接进行挂起，但有更新信息时，再将信息发送给浏览器端。浏览器端重新建立连接，如此循环反复，这是一种长连接的方式。 123456789轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源。 实例：适于小型应用。长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资源小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 操作系统线程和进程的区别做个简单的比喻：进程=火车，线程=车厢 线程在进程下行进（单纯的车厢无法运行） 一个进程可以包含多个线程（一辆火车可以有多个车厢） 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易） 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源） 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢） 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上） 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁” 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量” 进程 是什么： 先说概念：进程是os调度资源的最小单位（资源就是cpu的计算） 为什么： 为什么有进程这个东西？ 以前的os没有进程的，一次只能运行一个程序，单独享用cpu， 举个例子：我现在在打字聊天的同时在语音通话， 如果一次执行一个程序的话，就不能跟你们语音，只能是先打字， 打完之后再跟你们发语音，一次性只能做一件事 这样做的效率非常低，所以引进多进程是为了提高效率 另外，单独的一个进程在运行的时候，cpu的占有率也不是特别高， 或者进程在空闲等待io操作的时候，cpu的利用率就不高， 所以引进进程来提高cpu的使用率； 怎么做： 把cpu的运行切分成了多个时间片， 每一个当前正在占用cpu的程序都是一个进程， 这些进程在分别占有cpu的时间片， 比如印象笔记占1毫秒，qq占1毫秒，chrome占1毫秒， 它们在1秒钟之内切换了无数次，所以让你觉得他们是同时在运行的。 删（插一句：视频也是由每一帧画面片段组成的，只是因为它切换的特别快，所以看起来是连续的） 再就是：进程就是当前正在占用cpu的程序， 进程和程序之间的关系就是：程序是写死指令集合、进程是动态（它占有资源，如系统堆栈等）运行的程序…听起来有点绕，不知道讲清楚没有 进程的切换、调度有很多算法，不知道这些面试会不会问到，有兴趣的可以去了解下（ 引入线程是因为进程的切换开销大、进程之间通信效率低。 ======================================================================================== 线程 那什么是线程呢， 线程是比进程更小的单位。 打个比喻：多进程是cpu的多个儿子，线程是进程的多个儿子，他们是用的差不多的模型 所以线程是更细粒度的占用资源的单位，为的也是提高运行效率 多线程我也举个例子： 我现在开着印象笔记，它是一个进程，但是它同时还在做更多的事，比如检查我鼠标的操作，检查有没有更新之类的，也就是多个线程在瓜分同一个进程，共享共同的一些数据；（多个线程在做不同的事） 进程和线程共享资源的方式不一样， 程之间通信有它的方式比如用文件、管道（pipe）、Socket。线程之间共享资源就是同一个进程的栈帧（开启的资源），相当于是一个全局的数据 换句话说，每一个不同的进程都占有一块独有的区域（所以他的通信麻烦一些），每一个不同的线程共享同一块区域； 多线程有个同步问题，引起这个问题的原因是不同线程的执行顺序是不同的，不知道哪个先做哪个后做，比如有个线程A要读文件，线程B要写文件，正确的执行顺序是先让线程A写完文件之后，线程B再来读文件，们两个的步骤是：线程A写文件的步骤有：1）先打开文件；2）写文件； 3）关闭文件线程B读文件的步骤有：1）打开文件；2）读文件；3）关闭文件；如果没有经过处理的两个线程同时开启，就不知道哪个线程先执行，哪个后执行可能会出现A刚打开文件还没有写文件，就切到了B线程读文件，这个时候就出现问题了.. 解决这个问题有好几个办法，我讲一种加锁（互斥）操作，就是加了这个锁之后，只有一件事情完全做完之后再释放这个锁，把执行权交给另一个线程，还是按上面的例子：程序一开始给写文件的线程A的步骤1）加锁，当A的步骤3）结束之后再释放这个锁，如果没有释放的话，读文件的线程B就拿不到这个锁，无法执行； ======================================================================================== 但是加锁又会产生新的问题：死锁； 同步加锁会产生死锁问题，（参考哲学家就餐问题，以及银行家算法） 1）是什么：比如只有一个独木桥，有两个人分别在不同的边，你们都走了一半的距离，谁也不想走回去让另一个人过，于是就一直等在这。这就是死锁了 2）为什么： ​ 1- 一个资源每次只能被一个线程使用 ​ 2- 多个线程都在等待别人的资源 3）怎样做： ​ 1-让他们获取资源（使用这个桥）的顺序是一样的，A先走完，B再走； ​ 2-给更多的资源，多建几个桥； ======================================================================================== 并发、并行问题： 不管你运行着多少个进程，只要你系统能处理多个事情，就是并发的并行就是这些事情都是在同一时间运行的一个是时刻、一个是时间段，并发是时间段，并行是时刻 总结：进程是为了提高cpu利用率，线程提高进程利用率， 原码、反码、补码https://blog.csdn.net/zl10086111/article/details/80907428?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task CSS布局 Position1、static 默认是static，使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时的top、left等属性设置无效。 2、relative relative 是相对元素正常文档位置的情况下进行布局，使用top、left等属性使其相对原来的位置进行偏移。 3、absolute 绝对定位，脱离文档流布局。通过指定元素最近的非 static 定位元素的偏移，来确定元素定位置。可以设置外边距（margin），且不会与其他边距合并。 4、fixed 不为元素预留空间，而是指定元素相对于viewport的位置 来制定元素的位置 5、sticky 相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位 6、inherit 规定应该从父元素继承 position 属性的值。 盒模型 所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 IE 盒模型：width = content + border + padding 标准盒模型：width = content 12/*使用box-sizing选择使用那种盒模型*/box-sizing: content-box | border-box; Flex 布局采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 css垂直居中布局 绝对定位和负margin 绝对定位和transform 绝对定位和 calc 属性 table 标签 flex 布局 BFCBlock Formatting Contexts (BFC，块级格式化上下文)，就是 一个块级元素 的渲染显示规则。通俗一点讲，可以把 BFC 理解为一个封闭的大箱子，，容器里面的子元素不会影响到外面的元素，反之也如此。 BFC的布局规则如下： 1 内部的盒子会在垂直方向，一个个地放置； 2 BFC是页面上的一个隔离的独立容器； 3 属于同一个BFC的 两个相邻Box的 上下margin会发生重叠 ； 4 计算BFC的高度时，浮动元素也参与计算 5 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此； 6 BFC的区域不会与float重叠； 那么如何触发 BFC呢？只要元素满足下面任一条件即可触发 BFC 特性： body 根元素； 浮动元素：float 不为 none 的属性值； 绝对定位元素：position (absolute、fixed) display为： inline-block、table-cells、flex overflow 除了visible以外的值 (hidden、auto、scroll) 移动端适配方案1.使用百分比+媒体查询 test.1.html2.使用 flexbox3.使用 rem + viewport test.3.html4.使用 rem test.4.html5.固定布局视口宽度，使用 viewport 进行缩放 test.5.html 浏览器浏览器渲染页面的过程 浏览器使用流式布局模型 (Flow Based Layout)。 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 浏览器的回流与重绘 (Reflow &amp; Repaint)当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 JavaScript优化1、动画 可以优先采用requestAnimationFrame，实现动画帧的并发渲染 做减法，保留主动画性能，去除重要性不大的动画（跑马灯、过程小动画）等 大图动画性能消耗非常大，使用translate3d实现GPU 加速，动画结束、暂停是，切换回2d，取消加速。 按需加载／卸载动画; 每个动画帧处理函数简化，尽量减少或者去除回流、重绘。 2、加载用户体验的优化 首屏优先加载，保证用户体验的流畅性：优先加载欢迎界面图片的资源，所有图片load之后，在启动主动画资源的加载，与进度条动画。 资源的预加载，在进入主动画之前，进行主动画各资源的加载，当完成加载时，再promise结束进度条动画；。 常规优化：雪碧图、压缩、base64等 存储dom变量，减少dom tree的查找等； 3、避免回流 可以用transform等操作，来替代position；left等等的操作。当需要display:none的情况下（回流，不为元素保留其屋里空间），使用opacity:0（重绘）；或者visibility:hidden（重绘），将更优。回流的性能消耗要远大于重绘。 requestAnimationFrame它是一种动画高级的方法，存在兼容性问题。主要运作方式是浏览器要进行绘制的时候（一般16.7ms一次绘制），会通知requestAnimationFrame们，requestAnimationFrame们就跟它一起绘制。这里有几个好处，多个requestAnimationFrame可以同时进行，而setTimeout需要独立绘制；页面切换等情况，浏览器不再绘制该页面，requestAnimationFrame也停止了绘制，与浏览器同步，资源很省。相对setTimeout，是一个js的执行栈，只能串行执行，并且会影响其他js的处理。所以，使用前者，性能更佳，更流畅，交互体验更佳。特别是多个动画同时进行时，前者毫无压力，后者表示卡顿厉害。 write 和 innerHTML 的区别write 是DOM的方法，向文档写入HTML表达式或者JavaScript代码，可以列出多个参数，参数被顺序添加到文档中；innerHTML是DOM属性。 write 方式会开启一个新的文档，导致页面内容的重写，innerHTML直接将内容写入DOM节点，不会导致页面的全部重回。innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的哪一个部分。 事件委托机制通俗来讲就是把一个元素的响应事件函数，委托到另一个元素。举个例子，就是有一堆li标签，需要给每一个li标签添加click事件，但是如果有几万个li标签，每个标签都显式地去添加事件函数，会影响性能。这里有一个解决方案就是把li的事件函数，委托到它的上一层父级ul标签去（假如它的父级是ul） 这里首先在父级ul上定义一个事件监听，变量event是回调函数获取到的事件对象，target变量是#list元素下被点击的li目标元素，通过这个target变量，我们可以获取一些例如nodeName和id这种属性。然后就是通过属性判断是否是点击的li的一些逻辑。 函数柯里化好处： 1、参数复用 例如： 1234567var request = function(params, url, method) &#123; // 请求。。。&#125;request('https://abc.com', 'GET', &#123;a: 1, b: 2&#125;);request('https://abc.com', 'GET', &#123;a:2, b:4&#125;);request('https://abc.com', 'POST', &#123;a: 3, b: 2&#125;); 可以看到上面的调用重复写了一些参数，如果进行柯里化后，可以写成下面的样子。 12var getRequest = curringRequest('url');getRequest(&#123;a: 2, b:2&#125;); 2、延迟运行 参考bind的实现机制。 12345678Function.prototype.bind = function (context) &#123; var _this = this var args = Array.prototype.slice.call(arguments, 1) return function() &#123; return _this.apply(context, args) &#125;&#125; 继承原理一、理解原型js创建的每个函数都有一个prototype属性，这个属性指向一个对象。这个对象用来存储通过这个函数所创建的所有实例共有的属性和方法， 这个对象称为所有实例的原型对象。每个原型对象都包含一个constructor属性，它指向prototype属性所在的函数。 二、搜索对象属性的过程每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索proto指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。 通过实例只能访问原型对象的值，不能修改原型对象的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那么就会在实例中创建该属性，该属性将屏蔽掉原型中的那个属性。 闭包闭包就是有权访问另外一个函数作用域中的变量的函数。 各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包最重要的一个作用就是把某些变量隐藏起来，让外面的程序不能直接访问。 深拷贝 浅拷贝 – 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变不会使原数据一同改变 改变不会使原数据一同改变 深浅拷贝的实现方法浅拷贝： 1、=复制2、Object.assign() 方法 深拷贝： 1、递归2、Object.create()3、JSON做字符串转换4、还有一些其它的第三方函数库有深拷贝function，如lodash 函数防抖和节流函数防抖：函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 事件冒泡与实践捕获时间事件是先捕获，后冒泡 捕获阶段是外部元素先触发然后触发内部元素 冒泡阶段是内部元素先触发然后触发外部元素 如何阻止事件冒泡？如何取消默认事件？如何阻止事件的默认行为？ 阻止事件冒泡： W3C: stopPropagation(); IE: e.cancelBubble=true; 写法 : window.event ? window.event.cancelBubble=true:e.stop(Propagation) 取消默认事件 W3C：preventDefault() IE: e.returnValue:false; 阻止默认行为： return false 原生的js会阻止默认行为，但会继续冒泡； jquery会阻止默认行为，并停止冒泡。 虚拟 DOM 对象的 Diff 算法diff算法首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 在第一步算法中，需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。 在第二步算法中，需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。 举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更 defer 和 async 的区别在页面加载的过程中， async 会将 js的加载与执行文档的加载并行进行，defer 会将js的加载与文档加载并行执行，js的执行在加载之后。 宏任务和微任务macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick, Promises, Object.observe(废弃), MutationObserver 在 js 执行是，主线程会有一个事件队列以及事件循环，事件队列存放着需要处理的各种事件，这个循环则不段处理各种事件或者消息。 宿主环境提供的叫宏任务，由语言标准提供的叫微任务，常见的两种宿主环境有浏览器和 node。 宏任务本质：由宿主环境提供的参与事件循环的任务 微任务本质：直接在 Javascript 引擎中的执行的，没有参与事件循环的任务。 宏任务，微任务的优先级 promise 是在当前脚本代码执行完后，立刻执行的，它并没有参与事件循环，所以它的优先级是高于 setTimeout。 js 的运行机制 第一个是JavaScript Engine，chrome 的引擎就是 V8（提供调用栈、内存 heap） 第二个是 WEb API，提供一些 dom 操作、ajax 的操作 第三个是 回调队列，也就是Web API 里的回调函数，回放入到回调队列中 第四个是事件循环，也就是宏任务、微任务的容器 call stack 是追踪函数执行流的一种机制，通过调用栈，可以知道当前哪一个函数正在被执行。每当调用一个函数，解释器就将改函数添加至调用栈并开始执行。如果正在执行的函数还调用了其他函数，那么新的函数也会被添加至调用栈中。当调用栈空间被占满时，就会引发“堆栈溢出”。因为只有一个调用栈，所以被称为单线程。 callback queue 回调队列，在 JavaScript 的编译阶段，将一些事件放置在执行队列中。 EventLoop 事件循环 将callback queue 中的事件放在 call stack 中执行 事件循环JavaScript 是单线程的，执行一些耗时较长的段任务是，页面会卡，无法响应， Webpack原理过程Webpack 的构建流程可以分为以下三大阶段： 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。 编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。 输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下： 在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。 TreeShaking 原理是什么：TreeShaking 的本质工作是消除无用的 JS 代码，称之为 DCE(dead code elimination) 为什么：js 与传统的编程源于不同的是，绝大多数代码是通过网络加载后执行，加载的文件大小越小，整体执行时间更短。所以去除无用代码以减少文件体积，对javascript来说更有意义。 原理：依赖于 ES6 的模块特性，依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析 缺点：具有Side Effect，side effects是指那些当import的时候会执行一些动作，但是不一定会有任何export。比如ployfill,ployfills不对外暴露方法给主程序使用。 Webpack 代码压缩1、js 文件的压缩 Webpack 4 内置了uglifyjs-webpack-plugin，mode 设置为production默认开启代码压缩。 2、css 文件的压缩 使用optimize-css-assets-webpack-plugin 同时使用cssnano 配合MiniCssExtractPlugin插件把css单独分离成一个文件 配置： 12345678910plugins:[ new OptimzeCSSAssetsPlugin(&#123; assetNameRegExp:/\.css$/g, cssProcessor:require('cssnano') &#125;)] 3.html文件的压缩 依赖html-webpack-plugin插件 配置：（设置参数） 1234567891011plugins: [ new HtmlWebpackPlugin(&#123; // 打包输出HTML title: 'Hello World app', minify: &#123; // 压缩HTML文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true// 压缩内联css &#125;, filename: 'index.html', &#125;),] Webpack 优化 优化开发体验优化开发体验的目的是为了提升开发时的效率，其中又可以分为以下几点： 优化构建速度。在项目庞大时构建耗时可能会变的很长，每次等待构建的耗时加起来也会是个大数目。 4-1 缩小文件搜索范围（loader 配置） 4-2 使用 DllPlugin（复用模块不重复打包） 4-3 使用 HappyPack（利用子进程） 4-4 使用 ParallelUglifyPlugin（多个子进程压缩代码） 优化使用体验。通过自动化手段完成一些重复的工作，让我们专注于解决问题本身。 4-5 使用自动刷新 4-6 开启模块热替换 优化输出质量优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。 这至关重要，因为在互联网行业竞争日益激烈的今天，这可能关系到你的产品的生死。 优化输出质量本质是优化构建输出的要发布到线上的代码，分为以下几点： 减少用户能感知到的加载时间，也就是首屏加载时间。 4-7 区分环境 4-8 压缩代码 4-9 CDN 加速 4-10 使用 Tree Shaking 4-11 提取公共代码 4-12 按需加载 提升流畅度，也就是提升代码性能。 4-13 使用 Prepack 4-14 开启 Scope Hoisting Babelbabel-loader，babel-core，babel-polify，babel-plugin-transform-runtime之间的关系: babel-core：是Babel编译器的核心，把 js 代码分析成 ast，使用babel 的其他库都需要先安装 core。babel-loader：模块转换器，将模块的内容按照需求装换成新内容。 babel-plugin-transform-runtime: 运行时引入 generators/async、babel-runtime/core-js（ES6-&gt;includes….）不会污染全局环境。 @babel/preset-env：转化最新语法如箭头函数，想要转换最新的api还需引入babel-polyfill（eg: includes） @babel/polyfill：一些新的api：Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 Git工作区、缓存区工作区：不包括.git在内的整个项目workspace 缓存区：版本库中包含了缓存区和 HEAD 指向的分支，使用 git add 命令会将修改的文件存放到缓存区。 git merge 和 git rebase 区别merge 的特点： 会自动创建一个新的 commit，并让合并的头节点指向 合并遇到冲突需要解决，修改后重新commit 有点事记录了真实的commit 情况，包括每个分支的详情，缺点是每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。 rebase 的特点： 找到两个分支的公共组建节点，会合并之前的commit历史 优点：得到更简洁的项目历史，去掉了merge commit 缺点：如果合并出现代码问题不容易定位，因为re-write了history 代码Promise.All12345678910111213141516171819202122function isPromise(obj) &#123; return obj &amp;&amp; (typeof obj === 'obj' || typeof obj === 'function')&#125;const myPromiseAll = (arr) =&gt; &#123; let result = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (isPromise(arr[i])) &#123; arr[i].then(res =&gt; &#123; result[i] = res; if (result.length === arr.length) &#123; // 遍历完成 resolve(result); &#125; &#125;， reject) &#125; else &#123; result[i] = arr[i]; &#125; &#125; &#125;)&#125; CanvasglobalCompositeOperation组合实现globalCompositeOperation用于控制源图像在目标图像上的显示方式。 源图像: 指你准备绘制到画布上的图像 目标图像：在画布上已经绘制的图像 属性值： 值 描述 source-over 默认。在目标图像上显示源图像。 source-atop 源图像为透明的，只有源图像与目标图像有交集的地方显示源图像，其他部分透明 source-in 源图像和目标图像都透明，只有源图像和目标图像有交集的地方不透明，且显示源图像 source-out 目标图像透明，源图像不透明，如果目标图像和源图像有交集的话，交集部分的图像透明 destination-over 将源图像绘制在目标图像的下层 destination-atop 目标图像透明，源图像不透明，如果目标图像和源图像有交集的话，在交际部分显示目标图像 destination-in 源图像和目标图像都透明，只有目标图像和源图像交集的部分不透明且显示目标图像 destination-out 目标图像不透明，源图像透明，如果目标图像和源图像有交集的话，交集部分图像透明 lighter 源图像和目标图像一起绘制在画布中，如果两者之间有交集的话颜色会进行叠加 copy 画布上只显示源图像，目标图像都不在画布中显示 xor 源图像和目标图像都在画布中显示，如果两者之间有交集的话，交集部分不显示图像 作者：闲余幽梦链接：https://www.jianshu.com/p/dd0487ff4293来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 图片合成：canvas.toDataURL(type, encoderOptions) 小程序小程序底层构架2.1 双线程模型 小程序的渲染层和逻辑层分别由2个线程管理： 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView线程。 逻辑层：采用 JsCore 线程运行JS脚本。 视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。 （页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面） 双线程模型 双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。 https://www.jianshu.com/p/ca720137818f 安全CSRF 攻击与防御CSRF 是一种网络攻击的方式，攻击者可以在受害者毫不知情的情况下以受害者，伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。 举个例子，A 在银行有一笔存款，通过对银行网站发送请求http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 A 把 1000000 的存款转到 B 的账号下。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 CSRF 攻击的对象在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。 CSRF 防御策略 验证 HTTP Referer 字段 在请求中添加 token 在 HTTP 头中自定义属性并验证 将 cookie 设置为 HttpOnly：只允许通过 HTTP 请求的方式读取cookie XSS 攻击1、反射型 XSS 反射型XSS的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。 攻击步骤如下： \1. 攻击者在url后面的参数中加入恶意攻击代码。\2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。\3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。\4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。 2、存储行 XSS 存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。 \1. 攻击者将恶意代码提交到目标网站数据库中。\2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。\3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。\4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。 如何防范？\1. 后端需要对提交的数据进行过滤。\2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。 3、DOM-based 型XSS \1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。\2. 用户打开带有恶意代码的URL。\3. 用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。\4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。 防范： 防御HTML编码。编码规则：将 &amp; &lt; &gt; “ ‘ / 转义为实体字符。 防御HTML Attribute编码。除了字母、数字、字符以外，使用 &#x;16进制格式来转义ASCII值小于256所有的字符。 防御之javascript编码。在onlick 等事件中，需要进行转码， React 和 Vue 的区别上面主要梳理了react和vue的4点不同： 数据是不是可变的 通过js操作一切还是各自的处理方式 类式的组件写法还是声明式的写法 什么功能内置，什么交给社区去做 （其中第3点在vue3.0支持类式写法之后就可以去掉了） react整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，而vue是基于可变数据的，支持双向绑定。react组件的扩展一般是通过高阶组件，而vue组件会使用mixin。vue内置了很多功能，而react做的很少，很多都是由社区来完成的，vue追求的是开发的简单，而react更在乎方式是否正确。 Flutter 与react 的区别 类型 React Native Flutter 语言 JavaScript dart 环境 JSCore Flutter Engine 发布时间 2015 2017 star 78k+ 67k+ 对比版本 0.59.9 1.6.3 空项目打包大小 Android 20M(可调整至 7.3M) / IOS 1.6M Android 5.2M / IOS 10.1M GSY项目大小 Android 28.6M / IOS 9.1M Android 11.6M / IOS 21.5M 代码产物 JS Bundle 文件 二进制文件 维护者 Facebook Google 风格 响应式，Learn once, write anywhere 响应式，一次编写多平台运行 支持 Android、IOS、(PC) Android、IOS、(Web/PC) 使用代表 京东、携程、腾讯课堂 闲鱼、美团B端 React 父子组件生命周期的执行顺序A组件包裹B组件，B组件包裹C组件，它们的 componentDidMount 触发顺序如何。 1、父类执行 ComponentWillMount 2、父类执行render 3、子类执行ComponentWillMount 4、子类执行render 5、子类执行ComponentDidMount 6、父类执行ComponentDidMount ReactRouter保证视图和URL的同步,而视图可以看成是资源的一种表现。当用户在页面中进行操作时，应用会在若干个交互状态中切换，路由则可以记录下某些重要的状态，比如在一个博客系统中用户是否登录、在访问哪一篇文章、位于文章归档列表的第几页。而这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的前进、后退按钮切换状态，同样可以将 URL 分享给好友。用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源（当然，资源也可能存在于本地），成功后重新绘制 UI，原理如下图所示： HTML 新特性html5总的来说比html4多了十个新特性，但其不支持ie8及ie8以下版本的浏览器 一、语义标签 二、增强型表单 三、视频和音频 四、Canvas绘图 五、SVG绘图 六、地理定位 七、拖放API 八、WebWorker 九、WebStorage 十、WebSocket 排序算法的选择前端工程化前端的开发框架以 Vue 为主，使用 Webpack 解决接口 mock、代码检查、代码编译、构建、压缩、添加版本号、部署等全流程的工作。涉及到的技术点有 Vue、Vuex、ESlint、stylelint、Mock、Webpack、Sass、PostCSS 等。对前端的要求相比几年前已经从单纯的 JS、CSS 问题变成了更多工程化为主的问题。 如何进行高效的多人协作？ 如何保证项目的可维护性？ 如何提高项目的开发质量？ 如何降低项目生产的风险？ 前端趋势前端工程化小程序在微信小程序出现以前，大家在谈 Hybird、ReactNative，但终归只是技术层面的狂欢，始终没有业务属性的注入。小程序的出现，一方面告诉业界在当前设备上 Webview 也没差到哪去，另外一方面告诉业界如何让有能力的商家在超级 APP上进行私域运营。 另一方面，从技术角度说，在上层 DSL 的严格限制下，超级 APP 就可定义符合自己诉求的 Web 标准，弥补当前 Web 标准的不足，最后和客户端配合，结合离线、预加载、定制Webview 能产出类似于 NSR 等各种酷炫的技术模型，让 Web 在端内低成本达到 Native 版的体验，端外也不会像 Weex 一样有点小别扭。 不过由于需要依赖超级APP（微信、支付宝、百度、美团、头条等），由于各家平台采用的具体方案的差异，造成目前小程序的落地方案也不一样，有时候需要开发多套代码。 跨端开发跨端开发⽅⾯，RN ⽣态已经⾮常成熟，或者说看不到太多发展前景，因为目前还停留在0.61版本，似乎1.0版本仍然遥遥无期。因此，今年很多团队转战⾕歌⽣态的 Flutter，特别是 Flutter for Web 的第⼀个 Release，⼜让 Web 前端重燃希望、跃跃欲试。 同时，苹果公司也发布了全新的 UI 系统——SwiftUI，同时，开源社区中 SwiftUI for Web已经在路上了，SwiftUI for Android 还会远吗？ ServerlessServerless 的⽕爆⼏乎可以归因于前端。因为 Serverless 能够较完美的⽀持Node.js，使⽤ Serverless 帮助前端开发者解决了使⽤Node.js 过程中的诸多问题。 当前的前端工程师大多都是科班出身，虽不能和正宗的服务端开发同学比，但也可写很多服务端层的业务逻辑。当前已经有很多公司在做 BFF 层，来满足这部分诉求，但依旧摆脱不掉运维、机器分配 这条拦路虎。随着 Serverless 的逐步落地，BFF 这层的代码会摆脱运维、机器分配等复杂的问题，同时大概率会由前端同学写这部分代码，服务端同学专注中台系统的实现。从业务上说，业务的试错成本也会大幅度降低。 5G2019年一个绕不开的话题就是5G。⾸先，5G 带宽的⼤幅提升带来传统 Web ⻚⾯复杂度的进⼀步提升，如同 2G 到 4G 变⾰过程中⻚⾯从 WAP 的纯⽂本超链接时代变⾰到 4G 全图⽚视频时代。5G 对于⻚⾯的变⾰必将是巨⼤的，但肯定不会⼀蹴⽽就。因为相应的配套设施也需要逐步完善，如硬件性能和浏览器的处理速度。⽽服务端渲染（SSR）肯定是其中⼀个捷径，轻前端重后台，5G 是桥梁，把渲染放后台，不像同构那么简单，需要关注和优化渲染性能。WebAssembly 或许会在这个机遇下得到快速发展，因为它可以⽆缝对接后台多种语⾔，⽽后台渲染的优化也会带来前端⻚⾯研发模式和技术架构的变⾰。 其次，5G 带来的万物互联，⼜将带来有别于智能⼿机和普通 PC 的多样化的应⽤场景，VR、可穿戴设备、⻋载系统、智能投影、智能交互等⼜会把 Web 带⼊各种各样的垂直领域，这也意味着前端将有更多⼴阔的空间。相信随着5G的大规模商业，会诞生一批新的互联网巨头。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nCoV 下的生活记录]]></title>
    <url>%2F2020%2F01%2F27%2FnCoV-days-note%2F</url>
    <content type="text"><![CDATA[今年的 nCoV 病毒在春节期间肆虐全中国，而我又从武汉回来不久，自然成为重点关注对象，可以说是过了一个不同寻常的年。 这几天，一直在关注新闻以及朋友圈，每天醒来第一件事情就是看病情进展，刷各种消息。等到一天终了，又怀着忧愤入眠。一天天刷下来，内心一次次感到挫败、沮丧、焦虑、愤怒、紧张，一个人很容易陷入压抑的情绪中去。 受到 eBooksPlan 公众号文章自我隔离的第 1 天启发，也用文字记录一下 nCoV 笼罩下的生活，是有限生活的一部分，也是对自己的一种调节吧。保持开朗的心态，积极面对。 纯粹记录，无任何参考价值 2020.01.24 年三十今天年三十，开心了一些。上午帮家里贴了春联，打扫了一下卫生，下午和妈妈一起准备了年夜饭。期间不断收到社区的电话关怀，让我注意如果身体有不适要及时上报，并说会上门测量体温，感谢社区的关怀。 晚上和爸妈还有妹妹一起看春晚，一起看小品，一起欢笑，收到来自好朋友的祝福，这是最开心幸福的时刻，最近的压抑气氛暂时消散。又拍了年度自拍，今年看起来瘦了，也似乎更成熟了一些。 2020.01.25 大年初一大年初一，早起去给楼下的爷爷奶奶还有大伯拜了年，然后就上楼在家里呆着了，一天没出门，也没有人来家里拜年。下了西瓜视频，把《囧妈》投屏到电视上看，电影一般，纯粹用来打发时间，吃了一堆零食。 中午包了饺子，吃的很香。下午休息了一会后，又在刷各种群消息。看到一个比较信任的自媒体的筹款推送，捐了些钱。晚饭过后拿把吉他弹了会，开始一边听歌一边看一位博主推荐的书籍《十日谈》，简直就是本小黄书哈哈。 引用一下 eBooksPlan 公众号文章中的一句话，聊以慰藉： 陪陪家人或者享受孤独，不光是今年，也应该是平日里最大的美德。 2020.01.26 大年初二一大早，被小区内的大喇叭吵醒，喇叭内循环播放流感通知，告知严重性。一时间人们开始紧张起来了，并围在一起纷纷议论。小区大门被堵，外人和车不得进入，那些还准备去串门拜年的人是彻底死心了。 妈妈还是去上班了，她说商城里的人很多，人们在疯狂储备食物，蔬菜被抢购一空。 自己呆在家看了一部名叫《多哥》的电影，豆瓣 8.8 分，真实故事改编，讲述雪橇手和雪橇犬奔波千里接力送血清的故事，温暖而又有力量，推荐。 下午和朋友们斗了会地主，连赢 8 把，心情舒畅。 打的一手烂牌，终结连胜🐶 晚上倒腾了一个 GitHub 仓库，用来记录 nCoV 的生活。GitHub 地址：https://github.com/Mayandev/nCoV-notes 2020.01.27 大年初三早上起来看到科比去世的新闻，整个人顿时又丧起来了。不看 NBA 有一段时间了，但是一直很喜欢科比，喜欢他那拼的拚劲，相信也激励了很多人。 R.I.P 🙏 百度词条已经变为黑白 今天继续完善了 nCoV-note 项目，使用了 GitHub Actions 完成自动化的部署，项目只需要触发 push 和 PR 就可以自动变一项目，完成页面的构建。 希望有更多人来一起记录📝 下午实在憋得慌，偷偷跑到楼顶透透气，对着远方喊了两句。 晚上和家里人一起吃饭，喝了点自家酿的米酒，听爷爷讲他以前的传奇故事。爷爷可能也是憋得慌，今天的话比平时多很多。 关注疫情的同时，关注自己的心理变化，少刷手机动态，留出时间学习、阅读和思考。 2020.01.28 大年初四距离 14 天潜伏期结束还有三天，体温 36.5 ℃，一切正常。 天气渐晴，把洗好的衣服拿到窗外晾晒，心情格外的舒畅。拿上篮球，戴上口罩，到小区楼下球场打了会儿球，应该这些天唯一的运动。 小区内的大妈们带着口罩，跳起了广场舞，颇有一番风味。 下午看了会书，但是这知识它不进脑子🧠啊～在家学习有个不好的地方，注意力不够集中，也容易被各种事情打断。 晚上和家人一起看了电影《心花路放》，喜剧片，宁浩（我最爱的导演之一）导演，黄渤和徐峥主演。这种日子，和家人嗑着瓜子，喝着茶，聊着天，看着电影，笑一笑，或许这就是简单的快乐吧。 2020.01.29 大年初五早上起床，妹妹竟然给我煮好了面条，暖心❤️。 今天托朋友买的医用外科口罩也到了，应该够用一阵子。 2020.01.29 大年初五早上起床，妹妹竟然给我煮好了面条，暖心💗。 今天托朋友买的医用外科口罩也到了，应该够用一阵子。 已经一个礼拜没有出小区门，而新闻提醒最近的5-10天才是爆发期，更需要市民呆在家中，不得外出，防止病毒🦠扩散。父母早就已经不用我们去劝说，光是新闻播报就能够吓住他们，现在比我自个儿还紧张。 封闭的日子里每天都是重复的，这样的记录似乎无太大的意义，或许只是以后看到会浮现出一些画面，想起一些场景。 总之还是希望这样的日子早些过去，期待在不久的一天，我能大胆的脱下口罩，迎着阳光，露出会心的笑容😊。 就酱，先记到这，明天潜伏期的最后一天，冲！ 2020.01.30 大年初六今天的早饭是牛奶+奥利奥+散装面包+若干颗蓝莓，还是妹妹的花样多。 突然想将丢掉很多年的围棋捡起来，找了个人机对战的围棋网站，却发现连最简单的人机都下不过了。 我执白棋，毫无悬念的输了。 总是一心想吃掉对方，反而容易失去一大块“疆域”。围棋的输赢不是看谁吃子最多，而是看谁占的地盘最大。后面去 b 站看了一些教学视频，才慢慢的想起一些技巧。 下午花些时间整理了一些内容，写了一片推送：自我隔离时如何避免焦躁 晚上和喜欢的人聊了会天，互相倾诉了近期的情绪以及发生的一些事。 经历过这些事情后，想必大家都会更珍惜身边的人。 gay gay 的室友。 这个每日记录就先到这了，后面如果有新鲜事在写上去，但是 nCoV-note 上的内容我依然会每天收集并进行更新，欢迎关注。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>nCov</tag>
        <tag>流感</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载 ｜ NPM install -save 和 -save-dev 命令的区别]]></title>
    <url>%2F2020%2F01%2F07%2Fdifferences-in-npm-command%2F</url>
    <content type="text"><![CDATA[原文地址：https://www.limitcode.com/detail/59a15b1a69e95702e0780249.html NPM install -save 和 -save-dev 命令的区别我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式： 1234567npm install moduleName # 安装模块到项目目录下 npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。 npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。 npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目 node_modules 目录中保存模块包。 不会将模块依赖写入 devDependencies 或 dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 总结devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次录音棚录歌]]></title>
    <url>%2F2020%2F01%2F06%2Ffirst-record-song%2F</url>
    <content type="text"><![CDATA[2019 年末的时候去录音棚录了一首歌，接触到了新的东西，体验下了录歌这个过程。 关于录歌：1、价格。150元-200元/小时不等（武汉地区），一小时录完一首歌完全够用了，如果精修还需要额外的付费。 2、伴奏。版权原因一般录音棚不会提供伴奏，最好提前准备好伴奏。 3、歌词。可以不用打印歌词，一般录音棚都会有电子屏显示歌词。 一些感受：录音并没有像网上看到的那样容易，整个过程下来还是有点紧张的，录完出了一身的汗。本以为准备的还不错，但是在录的过程中还是会有各种小问题，最后录出来的效果似乎也没达到自己的预期。有的地方节奏没有踩好，有的地方直接就跑调了，好在后期挽救了一些。总之，唱歌还是有技巧，需要反复练习的。 Q&amp;A:Q：为什么要录歌？A：本来是准备本科毕业拉着室友们去的，也因为一些原因没有完成。其次是想感受和体验一下这个过程，也给2019画上个句号。 Q：录完歌需要多久能拿到？A：1-3天。 Q：不会唱歌的可以去录歌吗？A：可以的，相信自己！相信调音师的能力！ Q：录完可以上传到音乐平台上吗？A：可以的，某些歌曲需要提供版权文件。 End/总之，第一次录歌过程就以此文结束了。录完歌后回去简单学习了一下「库乐队」这个音频软件，现在也能够剪辑一些音频，加一些混响了，以后可以自己录歌自己修啦～ 我也开通了一个网易云电台，如果有新的作品会上传上去，欢迎订阅！ 扫描二维码打开：]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>录歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 年终总结]]></title>
    <url>%2F2019%2F12%2F25%2F2019-year-end%2F</url>
    <content type="text"><![CDATA[年终总结年终总结是从去年才开始决定要写的，希望以后能够延续这个好的习惯。去年的总结是以图文的方式保存，内容比较单一，只是简单的记录发生的一些事，缺少了一些总结和思考。 2019 年，就时间上来说，也算是具有划时代意义的一个年份。因为过了今年，我们就将告别 10 年代，步入全面建成小康社会时代。 还记得十年前的你在干些什么吗？我想了想，十年前，我好像开通了QQ并发了第一条空间说说；十年前，满两岁的妹妹好像会喊哥哥了；十年前，青春期的自己好像第一次有了心动的感觉。 哈，扯远了，下面开始才是正文～ 2019 去的地方和发生的事就我个人而言，2019 也是值得回忆的一年。因为我大学毕业了，并来到华科读研，从一个环境进入到另一个环境，结识了一帮新的朋友，对一些事情有了新的看法，也有很多的东西想要表达和分享。 去年的 log 是以时间轴的方式记录，今年就换种方式，以城市来总结记录吧。 西安今年 4 月初和室友一起去了古城西安，品尝了各种面食，领略了大唐风光，一些有名的景点几乎都去打卡了。夜晚的西安特别美，颇有韵味，尤其是钟楼鼓楼老城墙不夜街那一块儿，被灯光装点的金碧辉煌，熠熠生辉。 去逛了西工大、长安大学校园，感觉是充满工科气息的学校。找了在长安大学读书的弟弟吃饭，聊了聊近况，一切都好。 华山华山在西安的附近，高铁大约 40 分钟。为了看日出，爬了整整一夜，结果因为雾气太重，只能看到层层的云，有些许遗憾。不过也算是征服了一座山，爬山的途中也认识到一些人，还是很享受登山这个过程，走走停停，欣赏沿途的风景。 南昌今年 6 月， 被毕业论文忙得焦头烂额的时候，回南昌和之前的教官们一起拍了 07 式军装的照片。也算是给自己大学教官生涯画上了一个完美的句号吧，感谢这支队伍！ 之后，又在南昌举办一次毕业聚餐，邀请了学校的老师，同学们也都尽量赶了回来。这次聚餐不是很伤感，可能在南京已经哭过一次了。聚时一团火，散作满天星，老师同学们，你们现在还好么？ 南京南京待的时间较长，在南京完成了自己的毕业设计，然后实习了一段时间。对它不仅仅是一位外来游客对一座城市的直观印象，而是把自己融入到这座城市，去倾听去感受。一直很喜欢南京的天空，喜欢这城市的文化。 每次听到与南京有关的歌，思绪便会不自觉的想起在南京发生的点滴。很可惜，今年一位喜欢的歌手突然被封杀，他写过很多关于南京的歌，都很好听。 写到这，脑海里仿若又想起了南京的地铁的播报声：南京银行梅花卡提醒您，前方到站，玄武门站，请需要下车的乘客做好准备。Next station is XuanWuMen, Please ready to get off. 这里插播一首歌曲，希望你能点开听一听。 在南京遇到了很多有意思的人，有在南大读书的宝章兄，有温柔体贴的潘姐、豪爽的包包、可爱的姜钰和志敏，能与这么多小姐姐共事可能已经是我的人生巅峰了。 告别南京的时候还真的有点不舍呀，总之有机会一定会再去的。 武汉9 月份来武汉华中科技大学读书。 对于新的研究生生活，刚开始来的那段时间，一直有种莫名的失落。 首先是，导师研究的方向过于理论，自己似乎更适合动手实践的东西。其次，身边的同学都非常的优秀，有种莫名的落差感。 在这之后，我和导师谈话，决定换个导师，之前的导师也尊重我的选择，感谢他的包容与理解。 其次，自己也在一些活动中找到了一些归属感和成就感，也认识了很多人，整个人的状态便很快的调整过来了。上面的这个过程，我觉得也是一个自我认识的过程。 起初对华科最初的印象是对环境的一个客观感受，久之后，最大的感受可能就是人了吧，真的能够感受到他（她）们由内而外的自信，他们对学术的热情，对运动的激情，对艺术的追求。 似乎所有事情都能够做到极致，就像电影《绿皮书》中的一句台词：不管你做什么，都要做到极致，上班就认真工作，笑就尽情大笑，吃东西时，就像是最后一餐那样去享受。 这句台词在他们大部分人身上有了印证，是的，多向优秀的人学习。 来华科的一个较大变化就是变得喜欢记录自己的生活了，每天吃的东西，走在路上看到的景色，都会尽量地用文字或者图片去记录下来。 最好的相机就是当你想要拍摄照片时，你手上的那一部 可能是因为在大学生活所剩无几了，所以现在无比珍惜在大学里的每一刻。 当然，对于自己的学习，也在朝着奖学金努力，在保证完成基本课程学业的同时，去接触新的知识和技术，然后动手实践，虽然现在没有以前的那种热情，但依然保持着专注。 That’s it! 2019 年看过的电影《82 年生的金智英》、《误杀》、《少年的你》、《双子杀手》、《小丑 Joker》、《续命之徒：绝命毒师电影》、《小丑回魂2》、《我和我的祖国》、《杀人回忆》、《请回答 1988》、《寄生虫》、《痛苦与荣耀》、《燃烧》、《疾速备战 3》、《哪吒之魔童降世》、《绿皮书》、《恶人传》、《切尔诺贝利》、《孟买酒店》、《怪奇物语 3》、《蜘蛛侠：英雄远征》、《X战警：黑凤凰》、《黑衣人：全球追缉》、《反贪风暴4》、《哥斯拉2：怪兽之王》、《雷霆沙赞》、《宠物坟场》、《过春天》、《蜘蛛侠：平行宇宙》、《新喜剧之王》、《风中有朵雨做的云》、《复仇者联盟4：终局之战》、《触不可及(美版)》、《碟中谍6：全面瓦解》、《小偷家族》、《调音师》、《黑袍纠察队》、《来电狂响》、《流浪地球》、《波西米亚狂想曲》、《绝杀慕尼黑》、《极限逃生》、《大黄蜂》、《飞驰人生》、《疯狂的外星人》 2019 年看过并在豆瓣标记了大概 40 来部电影，最喜欢的 Top5 : 《绿皮书》、《复仇者联盟4：终局之战》、《波西米亚狂想曲》、《少年的你》、《小丑 Joker》 来华科读书后电影看的很少了，一是去电影院不是很方便，其次也很难找到一大段空闲时间来单独欣赏一部电影。 对于电影，现在也更喜欢一些简单的叙事型电影，把一个故事讲好，再加上一些构图精致的镜头画面，是十分能打动人的。 2019 年看过的书 除专业书外，今年貌似也没看过几本书。 自媒体时代，各种短视频、爽文盛行，看的书越来越少了，现在读一大段文字已经显得有一点点吃力。还是得静下心来，多读一些书。 2019 年听过的歌 听歌风格还是没怎么变，依然喜欢民谣、轻摇滚和一些纯音乐。 2020 年要做的愿景： 去看一场赵雷的演出（如果有的话） 去北京玩（已经买票了） 去录音棚录一首歌（在准备了） 找到合适的实习工作 多陪家人 被喜欢的人喜欢 最后以朴树的《New Boy》中的歌词来结束这篇总结，新年快乐！ 明天一早，我猜阳光会好，我要把自己打扫，把破旧的全部卖掉。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>总结</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「一些思考」什么才是有意义的生活]]></title>
    <url>%2F2019%2F12%2F19%2Fwhat-is-meaningful-life%2F</url>
    <content type="text"><![CDATA[我们到底是活了365天，还是活了1天重复了364次？ 是不是追寻诗和远方才叫做有意义？ 某天夜晚，和室友们聊到了这个话题。 室友的一个想法我无比的赞同，他说有盼头的生活是有意义的。 是的，人为什么会有时候觉得生活无聊，大概率是失去了奋斗的目标。如果有一些事情值得为之努力，我想这样的生活是不会无趣的。 就好比考完研的同学，回想起备考的那些时光，肯定会觉得当时的那些日子都过的无比充实，很有意义。 所以，当自己觉得生活变得无趣的时候，给自己定下一些目标，朝着目标努力就好了。 前些天在操场上看球，碰到一位遛狗的大叔，撸狗暇间，和大叔闲聊。聊到自己专业的时候，大叔以一个过来人的身份来给了我一些建议，虽然之前素未谋面，但攀谈间还是倍感亲切和温暖。而大叔也谈到自己身体没有以前好了，工作不再那么拼，但还是努力的在让家里的生活变得更好。 所以要好好生活，每天开心一点，也给其他人带来一些快乐。 做一点不同的事，给自己一些小惊喜，给生活制造一些乐趣，同时也为自己的目标而努力奋斗，我想这就是有意义的简单的生活吧。 以上一些鸡汤～]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我收藏的小程序]]></title>
    <url>%2F2019%2F12%2F19%2Fmp-i-collect%2F</url>
    <content type="text"><![CDATA[对于自己来说，我既是小程序的使用者、也是小程序开发者。 因此，会经常关注小程序的一些发展动向，同时遇到好的小程序也会收藏起来。 下面我整理了我收藏的小程序并分享给各位，主要有图片制作、效率工具、资讯这三类，搜索小程序对应的名称即可使用。 图片类1. 告白小人儿 写下你的心里话，让小人帮你说出来。 小程序可以将你输入的文字制作成小人举牌的图片，支持 5 种不同风格的动漫小人。 2. 次元蜜蜂 由一位独立开发者开发的小程序，是一款图片生成工具。 有两个有趣的功能：二次元自拍和诺基亚短信图片生成器。 3. Pasty 水印相机 小程序可用于为图片添加苹果的 Logo 水印，满足了一部分果粉的需求。 小程序由一位科技博主 @Sunbelife 制作，虽然使用频率不是很高，但是设计十分简洁美观，值得学习，最爱的小程序之一。 4. 开源表情包 表情包是快乐之源！ 小程序是由 GitHub 上一个开源项目转换而来，目前总共有 50 多个分类，以 PR 的方式进行提交收集，表情包非常丰富，聚欢乐～ 5. 校徽头像制作 再小部分人需求也应该被满足！ 我自己开发的一个小程序，用于一键制作带校徽的头像。设计的比较直男风，审美确实还有待提升！ 工具类1. 微软 AI 识图 提高效率的神器！ 通过识别图片，提取图片信息，可智能生成 Office 文档。目前拥有拍图识字，高度还原表格，人脸识别制作文档，拍照翻译，拍照转 PDF/PPT 五项能力。 2. 腾讯文档 办公协同工具，填表格再也不用一个一个的发送信息了。 目前支持 Word 和 Excel 等办公类型的文档，具有多端同步、云端实时保存、支持多人协作编辑、浏览权限安全可控等特点。 3. 奶牛快传 通过少量的点击加上以秒为单位的时间，开启文件传输的旅程。 奶牛快传不只一次推荐了，目前支持网页端、小程序、App，具体特点可以看旧文：「效率工具」奶牛快传，文件传输神器 4. 一个木函 一款小巧清新、功能完善却不失纷繁与强大的集合类效率工具小程序。 小程序分为日常工具、极客工具、图片工具、文本工具四类，非常强大。有对应的 Android 端 App，体验更佳。 5. 神奇字体 由一位华科的学长开发，可以生成不同的特效字体，𝓵𝓸𝓿𝓮 𝔂𝓸𝓾 𝓽𝓱𝓻𝓮𝓮 𝓽𝓱𝓸𝓾𝓼𝓪𝓷𝓭 资讯类1. 垃圾分类 各地都慢慢要实行垃圾分类了，收藏这个小程序备用。 2. 岛读 Lite 一个极简主义的每日阅读。 每天一段优质的文字，从散文到诗歌、从小说到随笔。很喜欢小程序的 UI，很优美简洁。 3. Gitter 可能是颜值最高的 Github 小程序客户端，偶尔打开看看目前的流行的项目。 4. 糖纸 好产品的说明书。 被小程序的颜值所吸引，相关科技产品内容也非常优质。购买电子产品前可以先上去看看相关的介绍。 5. 口袋乐谱 很多优质的吉他谱，并且可以在线播放学习。吉他入门者可以收藏起来。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>小程序</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期购置的一些好物]]></title>
    <url>%2F2019%2F10%2F25%2Fgood-things-i-bought%2F</url>
    <content type="text"><![CDATA[双十一将至，相信大部分的人已经将自己心仪许久的商品置入了购物车。如果如果你还不知道买啥，这是我近期购置的一些好物，希望给可以你一些 options。 1. 米家台灯 之前一直用的小米 USB接口的 LED 灯，但是亮度不够，有点伤眼睛，适合夜晚放在床头。 于是月初购入了米家台灯，整个书桌变得都变得敞亮了起来。台灯的设计感很强，可调节亮度和色温。如果有无线网络环境，甚至可以使用手机和语音助手进行控制。 2. 显示器 AOC 2k，国产显示器，性价比和颜值都挺高的。可以上下移动、左右旋转。 阅读文档，写代码很适合。买前生产力，买后爱奇艺。 3. 安耳悠 安耳悠耳塞，被一位博主安利后买的。前段时间因为室友打呼有点影响睡眠，便购入了这款耳塞。便宜好用，隔音效果非常好，富有弹性，并且十分亲肤。 4. 棉手套 武汉渐渐入秋，骑电动车有些冻手，赶紧买了双棉手套，手感不错。预防冻疮，从戴手套开始。 5. 水杯 保温杯里泡枸杞，不多说，颜值即正义。 之前本想买网易云周边的水杯，后面这看到 GERM 的杯子有优惠券，便以百元以内的价格置入了。 6. 棉被 自从上周睡觉被冻醒之后，果断下单了南极人 7 斤的棉被保命。em… 现在窝在温暖的被子里码字。 7. 秋衣秋裤 穿秋裤是对冬天最起码的尊重～ 恒源祥的秋衣秋裤手感很舒服，等天冷了拿出来穿。 8. 润肤霜 天气干燥，皮肤容易起皮。买了 B 站上一位 up 主推荐的杰威尔男士护肤霜，开始做个精致的🐷🐷男孩。 9. 按摩器 天天对着手机电脑，现在脖子有点吃不消了。 前两天购入了颈部按摩器，希望能够缓解一下。 其实最重要的还是多休息～ 10. 鞋架 虽然没几双鞋，但是放整齐一些还是比较好的，寝室本来就小。整理了之后，地面看着舒服多了。 11. Nike 鞋 双十一 Nike 鞋降价，挑了一双（经济&amp;款式上）适合自己的鞋，付了定金。 下面的物品是一些目标，在将来看经济情况置入，你也可以在双十一考虑一下： 电动牙刷 airpods iPhone 11]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华科之初印象]]></title>
    <url>%2F2019%2F09%2F17%2Ffirst-look-hust%2F</url>
    <content type="text"><![CDATA[华科很大，大到一条地铁线有三个站从此经过，大到从宿舍到上课的地方来回大概有7、8公里。 华科的树很多，几乎到任何地方，都可以不晒着太阳。 华科的同学很强，随便做了一辆校车，前后一问都是博士。 华科的同学遵守秩序懂得礼让，食堂买饭、等车都井然有序的排队，不争不抢。 华科的老师很有意思，数学老师讲话音调忽高忽地，有时候还会破音。 华科的老师很低调，有的就像少林寺扫地僧一般的存在。 华科，也充斥着太多生活气息，就好像一座微型的城市。 幼儿园，小学，初高中学，菜市场，各种银行，超市，麦当劳，路口的红绿灯，交警叔叔。 你能在一座城市看到的符号，华科这里都有。 希望能在华科找到那个她。 今夜月圆，骑着小电驴晚上在校园兜风是一种享受。 BTW，月饼节🥮快乐！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>大学</tag>
        <tag>华科</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「小技巧」学会用小程序提高效率]]></title>
    <url>%2F2019%2F08%2F26%2Fuse-mini-program-improve-effect%2F</url>
    <content type="text"><![CDATA[微信小程序，说烂了「即用即走」这个概念。 自从有了小程序，手机确实可以减少一些独立的 App，节约手机空间。 但更多时候，我们可以使用合适的小程序，减少不必要的工作，提高工作效率，节省时间。 举个例子🌰想象一下这样的场景，Tony 老师手上有 50 个课题，所有的课题整理在了一张 Excel 表格当中。 50 个同学随机抽取课题进行研究，最后需要将每个同学抽取的课题填入到表格中对应的姓名一栏。 老师时间宝贵，叫来了 Jack，让他尽快完成这项工作，Jack 二话不说，干了起来。 制作编号签：1h 进行抽签：0.5h 统计姓名：1h 总用时 2.5 h，不过还好，虽然累，总算完成了。 回到寝室，Jack 和室友 Phill 吐槽，说这种工作真累人。恰好 Phill 帮另外一个老师干了同样的活，但是不到10分钟就完成了。 Phill 是怎么做到的呢？ 他使用了两个小程序：「抽签工具」和「腾讯文档」 使用 「抽签工具」进行随机的编号抽签。 再将课题的 Excel表格 转为在线文档，使用「腾讯文档」多人协作的功能，让大家将对应的姓名填写进去。 整个过程如行云流水，效率是 Jack 的十几倍。 Jack 惊呼：🐂🍺！！ 总结工作中类似场景很多，利用好多人协作、识图、抽签等小程序工具，以及小程序与微信生态的深度结合场景，多发掘，多思考。 工具用的好，同学下课早！ 你用过哪些小程序来解决实际问题呢，欢迎留言。]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「小技巧」Win10 专业版系统激活]]></title>
    <url>%2F2019%2F08%2F26%2Fwin10-activation%2F</url>
    <content type="text"><![CDATA[系统重装后，激活这一步必不可少，否则大部分功能无法正常使用。 Win10 系统激活，适用于所有版本，可以收藏，以备不时之需。 注意：激活前请先连接网络⚠️ step1：打开命令行输入cmd-&gt;管理员身份运行Dos命令（如下图所示） step2: 输入激活命令依此输入以下命令： 1234&gt; slmgr.vbs /upk&gt; slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX&gt; slmgr /skms zh.us.to&gt; slmgr /ato step3: 激活成功 系统激活成功！！！此处应该有掌声👏👏]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Win10</tag>
        <tag>破解</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「码点代码」Python 实现图片拼接]]></title>
    <url>%2F2019%2F08%2F06%2Fimage-merge%2F</url>
    <content type="text"><![CDATA[Python 实现图片拼接最近写了一片文章：「有点好奇」我都追过哪些美剧，文章配图时想把看过的美剧海报拼接成一张图。 第一个想到的是使用 PS 导入拼接，但这种做法显得不够极客，于是决定使用 Python 代码实现图片拼接。 首先原图片是 24 张美剧海报图片，需要将其拼接为一张 3*8 的图片。 上图拼接效果如下： 代码实现对于图片的合并，需要读取本地图片，同时使用到 PIL 模块。因此如果你未安装此模块，可以使用 pip 进行安装。 模块代码如下： 12import PIL.Image as Imageimport os 随后定义一些常量： 1234567IMAGES_PATH = './serials/' # 图片集地址IMAGE_WIDTH = 200 # 每张小图片的宽度IMAGE_HEIGHT = 300 # 每张小片的高度IMAGE_ROW = 3 # 图片间隔，也就是合并成一张图后，一共有几行IMAGE_COLUMN = 8 # 图片间隔，也就是合并成一张图后，一共有几列IMAGES_FORMAT = ['.jpg', '.JPG', 'png'] # 图片格式IMAGE_SAVE_PATH = 'final.jpg' # 图片转换后的地址 这里需要对读取到照片数量进行判断： 1234567# 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item] # 简单的对于参数的设定和实际图片集的大小进行数量判断if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError("合成图片的参数和要求的数量不能匹配！") 最后通过循环对图片进行拼接： 1234567891011# 定义图像拼接函数def image_compose(): to_image = Image.new('RGB', (IMAGE_COLUMN * IMAGE_WIDTH, IMAGE_ROW * IMAGE_HEIGHT)) #创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(1, IMAGE_ROW + 1): for x in range(1, IMAGE_COLUMN + 1): from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize( (IMAGE_WIDTH, IMAGE_HEIGHT),Image.ANTIALIAS) to_image.paste(from_image, ((x - 1) * IMAGE_WIDTH, (y - 1) * IMAGE_HEIGHT)) return to_image.save(IMAGE_SAVE_PATH) # 保存新图image_compose() #调用函数 运行后拼接的图片如下图： 完整代码可以移步 Github 查看。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>图片拼接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「有点好奇」我都追过那些美剧]]></title>
    <url>%2F2019%2F08%2F04%2Fserial-i-like%2F</url>
    <content type="text"><![CDATA[今天来聊聊其他的，盘点一下我看过的那些美剧，顺便怀念一下我追剧的那些时光。 封面图是使用 Python 代码拼接的，你可以回复「图片拼接」获取代码。 说起追剧，身边的人可能会感到吃惊。一般人对我的印象可能就是只知道看书学习，不懂娱乐的一个 Nerd（书呆子）。 但其实，在闲暇时间，花过大量的时间来追自己喜欢的美剧。 高一的时候，因为考上了市里面的重点高中，厚着脸皮向家里要了 600 块钱买了一部金立的智能机，也是自己人生的第一部智能手机，并从此打开了新世界的大门。 从高二开始，到现在大四毕业，前前后后大约 6 年时间，看了将近 20 多部美剧，其中主要以「剧情」、「科幻」、「犯罪」、「喜剧」几种类型为主，虽然有的看到一半因为种种原因就弃了。 这可能对于其他剧狂来说并不算什么，但追剧对我来说算是最认真、也最疯狂的一件事了。 下面就以我自己观看的时间线，来罗列一下自己的看过的剧集，并附上我的一些观点以及推荐指数。 No.1 绝命毒师豆瓣评分（1-5季平均）：9.3 分 《绝命毒师》，英文名《Breaking Bad》，讲的是一位高中化学老师，因为受到种种生活上的打击，走上了制毒的道路。他利用其高超的化学技术提炼了高纯度冰毒，很快毒霸一方，但他的生活也逐渐坠落至万劫不复的深渊。 《绝命毒师》是我美剧的入坑剧，也是我心中的第一神剧，这也是为什么我一开始就对美剧产生了较为浓厚的兴趣。记得上晚自习的时候，拿手机蹭着学校的免费 WiFi（流量巨贵），将剧集下载好，然后回家细细品味。看的时候绝不快进，每一分钟都不错过，生怕忽略任何一个小细节。 我当时真的是以一种学习的心态来追这个（你信么）。我有一本单词本，记得全是字幕上的生词，有的现在依然记忆犹新。例如男二小粉对老白的怒吼：Bullshit，还有小粉的电话录音“what up bitaaaaaaaaach？leave it at the tone”，好像都不是什么好词（手动狗头）。 另外，关键就是这样的一部剧，我竟然还学会了很多化学知识，并且与课本有一个呼应，让我对某些知识有很深的印象。例如主人公老白为了偷制毒的化学原料，使用铝热剂烧掉门锁；被困在沙漠，老白自制锌电池给汽车发电点火。这些情节让我着迷，并对化学产生浓厚的兴趣，因此曾经的化学成绩一直还不错的。 所以在任何时候，我都不会吝啬对这部剧的赞美。 推荐指数：★★★★★ No.2 神盾局特工豆瓣评分（1-6季平均）：8.5 分 《神盾局特工》，英文名《Agents of S.H.I.E.L.D.》，属于漫威电影宇宙的系列作品之一，从电影系列的第二阶段开始。讲诉了纽约大战之后，外星人和超能力者不再是坊间传说的秘密，神盾局特工也投入到各种匪夷所思且疑云重重的危险事件的调查中去。 这部美剧也算是入坑的第一部超级英雄剧集，主要喜欢上了漫威相关的影视，还买了好多周边，口罩啊、卫衣啊等等。当时一直惊叹于电视剧的特效竟然能做到如此精良，因此这部剧也从高中一直追到大学。随着于漫威电影的衔接越来越多，故事情节也越来越紧凑。 漫威粉，喜欢超级英雄类的不容错过。 推荐指数：★★★★ No.3 闪电侠豆瓣评分（1-5季平均）：7.0 《闪电侠》，英文名《The Flash》，故事讲述了主角巴里·艾伦在一次粒子加速器爆炸的事故中被闪电击中后获得了极速移动的超能力，并在S.T.A.R.实验室的协助下，化身超级英雄闪电侠打击罪恶。 这部剧几乎是与《神盾局特工》同时追的，但是到第三部就有点走下坡路，剧情拖沓，一会东一会西，因此到后面也直接弃了。但值得一提的是，看完之后被强行科普了很多虫洞、时空穿越、相对论等等的知识。 DC粉，科幻迷，喜欢超级英雄类的值得一看。 推荐指数：★★★ No.4 摩登家庭豆瓣评分（1-10季平均）：9.5 《摩登家庭》，英文名《Modern Family》，剧集以群戏的方式演出，围绕三个互有亲戚关系的家庭，分别是一个普通中产阶级家庭、一个同性伴侣家庭和一个老少配夫妻的家庭，讲述了他们之间发生的一些趣事。 这部剧在高三暑假看的，所以几乎是一口气看完。第一季印象最为深刻，剧情一波三折，紧张刺激，配的BGM也很燃，每个角色都有很鲜明的特色，当时还剪了个和主角一样的寸头。后面的几季剧情就有些拖沓，完全是为了越狱而去越狱，但总体上还是一部不错的剧，值得一看。 推荐指数：★★★★ No.5 越狱豆瓣评分（1-5季平均）：8.3 《越狱》，英文名《Prison Break》，故事叙述主角的哥哥林肯·布鲁斯被诬陷杀害副总统之弟，被判处死刑并将于不久后执行。迈克尔·斯科菲尔德得知其兄的冤情后，秘密策划了一套详尽可行的计划，欲帮助林肯出狱。该剧第一季对悬念与节奏的把握恰到好处，成为脍炙人口的经典作品，但之后的续作反响平平。 这部剧在高三暑假看的，所以几乎是一口气看完。第一季印象最为深刻，剧情一波三折，紧张刺激，配的BGM也很燃，每个角色都有很鲜明的特色，当时还剪了个和主角一样的寸头。后面的几季剧情就有些拖沓，完全是为了越狱而去越狱，但总体上还是一部不错的剧，值得一看。 推荐指数：★★★★ No.6 查莉成长日记豆瓣评分（1-4季平均）：9.1 《查莉的成长日记》，英文名《Good Luck Charlie》。故事围绕六口之家展开，原本已经有三个孩子的 Duncan 夫妇又生下第四个孩子，可爱聪明的女孩Charlie。姐姐 Teddy 拿起DV摄像机，记录下 Charlie成长中所经历的以及这个家中所发生的一切有趣、有意义的事情。 《查莉的成长日记》大约是大一开始追的，当时上英语视听说课程的时候被英语老师安利的。老师每次都会空出半节课的时间给我们放上一集，大约20分钟，有点类似于中国版的「家有儿女」。关键是大家一起看，一起笑，一起吐槽，的确是一件有意思的事情。 推荐指数：★★★★★ No.7 怪奇物语豆瓣评分（1-3季平均）：8.9 《怪奇物语》，英文名《Strange Thing》。故事设定在上世纪80年代，印第安纳州霍金斯小镇上的一个男孩神秘失踪，他的朋友、家人以及当地的警察开始寻找答案，随着拥有超能力的女孩Eleven的出现，一个关于秘密实验和超自然力量的神秘事件被逐渐揭开。 这部剧大一的暑假开始追，当时只出了一季，躺在家里一口气看完了。剧中的怪物没有出现几次，但各种BGM以及阴暗的镜头，营造出了一种异常紧张刺激的气氛。几个小孩的演技也非常精湛，尤其是一位名叫达斯汀的小胖子，令人印象深刻。科技天才，每次说话都能让人捧腹大笑，并且三季了，还是个牙还没长齐说话漏风的小屁孩。 喜欢科幻惊悚的，力荐！ 推荐指数：★★★★★ No.8 权利的游戏豆瓣评分（1-8季平均）：9.0 《权利的游戏》，英文名《Game of Thrones》。故事背景中虚构的世界，分为两片大陆：位于西面的“日落国度”维斯特洛；位于东面的类似亚欧大陆。维斯特洛大陆边境处发现远古传说中早已灭绝的生物开始，危险也渐渐在靠近这里。 《权利的游戏》最后一季在今年4月份播出的，但是口碑扑街了，最后一季豆瓣评分6.1分。即使这样，1-8季平均依然能够达到9.0分，足以说明这依然是一部很不错的剧集。说实话，如果不是烂尾，在我心中绝对是第一神剧。 第一次看到这部剧是在接近期末考试的时候，当时没什么课，复习任务也不是很紧张，因此一次性刷完了好几季。第七季播出的时候，正参加数学建模比赛，大家都在紧张的准备，我还在偷偷的看（希望队友看到不会被打），不过最后也还是拿到了还不错的成绩。这部剧第一感觉就是这部剧很黄很暴力，越到后面剧情越来越紧凑，电影级别的特效，宏大的世界观，对人物的刻画也越来越有深度。必看美剧之一！！ 推荐指数：★★★★★]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>美剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「翻译」什么是卷积神经网络？为什么它们很重要？]]></title>
    <url>%2F2019%2F07%2F31%2Fwhat-is-cnn%2F</url>
    <content type="text"><![CDATA[原文链接：https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/ 卷积神经网络（ConvNets 或者 CNNs）属于神经网络的范畴，在图像识别和分类领域具有高效的能力。卷积神经网络可以成功识别人脸、物体和交通信号，从而为机器人和自动驾驶汽车提供视力。 在上图中，卷积神经网络可以识别场景，也可以提供相关的标签，比如“桥梁”、“火车”和“网球”；而下图展示了卷积神经网络可以用来识别日常物体、人和动物。最近，卷积神经网络也在一些自然语言处理任务（比如语句分类）。 因此，卷积神经网络对于今天大多数的机器学习用户来说都是一个重要的工具。然而，理解卷积神经网络以及首次学习使用它们有时会很痛苦。本篇博客的主要目的就是让我们对卷积神经网络如何处理图像有一个基本的了解。 如果你是神经网络的新手，我建议你阅读下这篇短小的多层感知器的教程，在进一步阅读前对神经网络有一定的理解。在本篇博客中，多层感知器叫做“全连接层”。 LeNet 架构 （1990s）LeNet 是推进深度学习领域发展的最早的卷积神经网络之一。经过多次成功迭代，到 1988 年，Yann LeCun 把这一先驱工作命名为 LeNet5。当时，LeNet 架构主要用于字符识别任务，比如读取邮政编码、数字等等。 接下来，我们将会了解 LeNet 架构是如何学会识别图像的。近年来有许多在 LeNet 上面改进的新架构被提出来，但它们都使用了 LeNet 中的主要概念，如果你对 LeNet 有一个清晰的认识，就相对比较容易理解。 上图中的卷积神经网络和原始的 LeNet 的结构比较相似，可以把输入的图像分为四类：狗、猫、船或者鸟（原始的 LeNet 主要用于字符识别任务）。正如上图说示，当输入为一张船的图片时，网络可以正确的从四个类别中把最高的概率分配给船（0.94）。在输出层所有概率的和应该为一（本文稍后会解释）。 在上图中的 ConvNet 有四个主要操作： 卷积 非线性处理（ReLU） 池化或者亚采样 分类（全连接层） 这些操作对于各个卷积神经网络来说都是基本组件，因此理解它们的工作原理有助于充分了解卷积神经网络。下面我们将会尝试理解各步操作背后的原理。 图像是像素值的矩阵本质上来说，每张图像都可以表示为像素值的矩阵： 通道) 常用于表示图像的某种组成。一个标准数字相机拍摄的图像会有三通道 - 红、绿和蓝；你可以把它们看作是互相堆叠在一起的二维矩阵（每一个通道代表一个颜色），每个通道的像素值在 0 到 255 的范围内。 灰度图像，仅仅只有一个通道。在本篇文章中，我们仅考虑灰度图像，这样我们就只有一个二维的矩阵来表示图像。矩阵中各个像素的值在 0 到 255 的范围内——零表示黑色，255 表示白色。 卷积卷积神经网络的名字就来自于其中的卷积操作。卷积的主要目的是为了从输入图像中提取特征。卷积可以通过从输入的一小块数据中学到图像的特征，并可以保留像素间的空间关系。我们在这里并不会详细讲解卷积的数学细节，但我们会试着理解卷积是如何处理图像的。 正如我们上面所说，每张图像都可以看作是像素值的矩阵。如下图一个 5 x 5 的图像，它的像素值仅为 0 或者 1（注意对于灰度图像而言，像素值的范围是 0 到 255，下面像素值为 0 和 1 的绿色矩阵仅为特例）： 同时，考虑下另一个 3 x 3 的矩阵，如下所示： 接下来，5 x 5 的图像和 3 x 3 的矩阵的卷积可以按下图所示的动画一样计算： 现在停下来好好理解下上面的计算是怎么完成的。我们用橙色的矩阵在原始图像（绿色）上滑动，每次滑动一个像素（也叫做“步长”），在每个位置上，我们计算对应元素的乘积（两个矩阵间），并把乘积的和作为最后的结果，得到输出矩阵（粉色）中的每一个元素的值。注意，3 x 3 的矩阵每次步长中仅可以“看到”输入图像的一部分。 在 CNN 的术语中，3x3 的矩阵叫做“滤波器（filter）”或者“核（kernel）”或者“特征检测器（feature detector）”，通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。记住滤波器在原始输入图像上的作用是特征检测器。 从上面图中的动画可以看出，对于同样的输入图像，不同值的滤波器将会生成不同的特征图。比如，对于下面这张输入图像： 在下表中，我们可以看到不同滤波器对上图卷积的效果。正如表中所示，通过在卷积操作前修改滤波矩阵的数值，我们可以进行诸如边缘检测、锐化和模糊等操作 —— 这表明不同的滤波器可以从图中检测到不同的特征，比如边缘、曲线等。在这里的 8.2.4 部分中可以看到更多的例子。 另一个理解卷积操作的好方法是看下面这张图的动画： 滤波器（红色框）在输入图像滑过（卷积操作），生成一个特征图。另一个滤波器（绿色框）在同一张图像上卷积可以得到一个不同的特征图。注意卷积操作可以从原图上获取局部依赖信息。同时注意这两个不同的滤波器是如何从同一张图像上生成不同的特征图。记住上面的图像和两个滤波器仅仅是我们上面讨论的数值矩阵。 在实践中，CNN 会在训练过程中学习到这些滤波器的值（尽管我们依然需要在训练前指定诸如滤波器的个数、滤波器的大小、网络架构等参数）。我们使用的滤波器越多，提取到的图像特征就越多，网络所能在未知图像上识别的模式也就越好。 特征图的大小（卷积特征）由下面三个参数控制，我们需要在卷积前确定它们： 深度（Depth）：深度对应的是卷积操作所需的滤波器个数。在下图的网络中，我们使用三个不同的滤波器对原始图像进行卷积操作，这样就可以生成三个不同的特征图。你可以把这三个特征图看作是堆叠的 2d 矩阵，那么，特征图的“深度”就是三。 步长（Stride）：步长是我们在输入矩阵上滑动滤波矩阵的像素数。当步长为 1 时，我们每次移动滤波器一个像素的位置。当步长为 2 时，我们每次移动滤波器会跳过 2 个像素。步长越大，将会得到更小的特征图。 零填充（Zero-padding）：有时，在输入矩阵的边缘使用零值进行填充，这样我们就可以对输入图像矩阵的边缘进行滤波。零填充的一大好处是可以让我们控制特征图的大小。使用零填充的也叫做泛卷积，不适用零填充的叫做严格卷积。这个概念在下面的参考文献 14 中介绍的非常详细。 非线性简介（ReLU）在上面图中，在每次的卷积操作后都使用了一个叫做 ReLU 的操作。ReLU 表示修正线性单元（Rectified Linear Unit），是一个非线性操作。它的输入如下所示： ReLU 是一个元素级别的操作（应用到各个像素），并将特征图中的所有小于 0 的像素值设置为零。ReLU 的目的是在 ConvNet 中引入非线性，因为在大部分的我们希望 ConvNet 学习的实际数据是非线性的（卷积是一个线性操作——元素级别的矩阵相乘和相加，所以我们需要通过使用非线性函数 ReLU 来引入非线性。 ReLU 操作可以从下面的图中理解。它展示的 ReLU 操作是应用到上面图 6 得到的特征图之一。这里的输出特征图也可以看作是“修正”过的特征图。 其他非线性函数，比如 tanh 或者 sigmoid 也可以用来替代 ReLU，但 ReLU 在大部分情况下表现是更好的。 池化操作空间池化（Spatial Pooling）（也叫做亚采用或者下采样）降低了各个特征图的维度，但可以保持大部分重要的信息。空间池化有下面几种方式：最大化、平均化、加和等等。 对于最大池化（Max Pooling），我们定义一个空间邻域（比如，2x2 的窗口），并从窗口内的修正特征图中取出最大的元素。除了取最大元素，我们也可以取平均（Average Pooling）或者对窗口内的元素求和。在实际中，最大池化被证明效果更好一些。 下面的图展示了使用 2x2 窗口在修正特征图（在卷积 + ReLU 操作后得到）使用最大池化的例子。 我们以 2 个元素（也叫做“步长”）滑动我们 2x2 的窗口，并在每个区域内取最大值。如上图所示，这样操作可以降低我们特征图的维度。 在下图展示的网络中，池化操作是分开应用到各个特征图的（注意，因为这样的操作，我们可以从三个输入图中得到三个输出图）。 下图展示了在图 9 中我们在 ReLU 操作后得到的修正特征图的池化操作的效果。 池化函数可以逐渐降低输入表示的空间尺度。池化的作用： 使输入表示（特征维度）变得更小，并且网络中的参数和计算的数量更加可控的减小，因此，可以控制过拟合 使网络对于输入图像中更小的变化、冗余和变换变得不变性（输入的微小冗余将不会改变池化的输出——因为我们在局部邻域中使用了最大化/平均值的操作。 帮助我们获取图像最大程度上的尺度不变性（准确的词是“不变性”）。它非常的强大，因为我们可以检测图像中的物体，无论它们位置在哪里（参考 18 和 19 获取详细信息）。 目前为止 到目前为止我们了解了卷积、ReLU 和池化是如何操作的。理解这些层是构建任意 CNN 的基础是很重要的。正如上图所示，我们有两组卷积、ReLU &amp; 池化层 —— 第二组卷积层使用六个滤波器对第一组的池化层的输出继续卷积，得到一共六个特征图。接下来对所有六个特征图应用 ReLU。接着我们对六个修正特征图分别进行最大池化操作。 这些层一起就可以从图像中提取有用的特征，并在网络中引入非线性，减少特征维度，同时保持这些特征具有某种程度上的尺度变化不变性。 第二组池化层的输出作为全连接层的输入，我们会在下一部分介绍全连接层。 全连接层全连接层是传统的多层感知器，在输出层使用的是 softmax 激活函数（也可以使用其他像 SVM 的分类器，但在本文中只使用 softmax）。“全连接（Fully Connected）”这个词表明前面层的所有神经元都与下一层的所有神经元连接。如果你对多层感知器不熟悉的话，我推荐你阅读这篇文章。 卷积和池化层的输出表示了输入图像的高级特征。全连接层的目的是为了使用这些特征把输入图像基于训练数据集进行分类。比如，在下面图中我们进行的图像分类有四个可能的输出结果（注意下图并没有显示全连接层的节点连接）。 除了分类，添加一个全连接层也（一般）是学习这些特征的非线性组合的简单方法。从卷积和池化层得到的大多数特征可能对分类任务有效，但这些特征的组合可能会更好。 从全连接层得到的输出概率和为 1。这个可以在输出层使用 softmax 作为激活函数进行保证。softmax 函数输入一个任意大于 0 值的矢量，并把它们转换为零一之间的数值矢量，其和为一。 反向传播正如上面讨论的，卷积 + 池化层的作用是从输入图像中提取特征，而全连接层的作用是分类器。 注意在下面的图中，因为输入的图像是船，对于船这一类的目标概率是 1，而其他三类的目标概率是 0，即 输入图像 = 船 目标矢量 = [0, 0, 1, 0] 完整的卷积网络的训练过程可以总结如下： 第一步：我们初始化所有的滤波器，使用随机值设置参数/权重 第二步：网络接收一张训练图像作为输入，通过前向传播过程（卷积、ReLU 和池化操作，以及全连接层的前向传播），找到各个类的输出概率 我们假设船这张图像的输出概率是 [0.2, 0.4, 0.1, 0.3] 因为对于第一张训练样本的权重是随机分配的，输出的概率也是随机的 第三步：在输出层计算总误差（计算 4 类的和） Total Error = ∑ ½ (target probability – output probability) ² 第四步：使用反向传播算法，根据网络的权重计算误差的梯度，并使用梯度下降算法更新所有滤波器的值/权重以及参数的值，使输出误差最小化 权重的更新与它们对总误差的占比有关 当同样的图像再次作为输入，这时的输出概率可能会是 [0.1, 0.1, 0.7, 0.1]，这就与目标矢量 [0, 0, 1, 0] 更接近了 这表明网络已经通过调节权重/滤波器，可以正确对这张特定图像的分类，这样输出的误差就减小了 像滤波器数量、滤波器大小、网络结构等这样的参数，在第一步前都是固定的，在训练过程中保持不变——仅仅是滤波器矩阵的值和连接权重在更新 第五步：对训练数据中所有的图像重复步骤 1 ~ 4 上面的这些步骤可以训练 ConvNet —— 这本质上意味着对于训练数据集中的图像，ConvNet 在更新了所有权重和参数后，已经优化为可以对这些图像进行正确分类。 当一张新的（未见过的）图像作为 ConvNet 的输入，网络将会再次进行前向传播过程，并输出各个类别的概率（对于新的图像，输出概率是使用已经在前面训练样本上优化分类的参数进行计算的）。如果我们的训练数据集非常的大，网络将会（有希望）对新的图像有很好的泛化，并把它们分到正确的类别中去。 注 1: 上面的步骤已经简化，也避免了数学详情，只为提供训练过程的直观内容。可以参考文献 4 和 12 了解数学公式和完整过程。 注 2:在上面的例子中我们使用了两组卷积和池化层。然而请记住，这些操作可以在一个 ConvNet 中重复多次。实际上，现在有些表现最好的 ConvNet 拥有多达十几层的卷积和池化层！同时，每次卷积层后面不一定要有池化层。如下图所示，我们可以在池化操作前连续使用多个卷积 + ReLU 操作。还有，请注意 ConvNet 的各层在下图中是如何可视化的。 卷积神经网络的可视化一般而言，越多的卷积步骤，网络可以学到的识别特征就越复杂。比如，ConvNet 的图像分类可能在第一层从原始像素中检测出边缘，然后在第二层使用边缘检测简单的形状，接着使用这些形状检测更高级的特征，比如更高层的人脸。下面的图中展示了这些内容——我们使用卷积深度置信网络学习到的特征，这张图仅仅是用来证明上面的内容（这仅仅是一个例子：真正的卷积滤波器可能会检测到对我们毫无意义的物体）。 Adam Harley 创建了一个卷积神经网络的可视化结果，使用的是 MNIST 手写数字的训练集13。我强烈建议使用它来理解 CNN 的工作原理。 我们可以在下图中看到网络是如何识别输入 “8” 的。注意下图中的可视化并没有单独展示 ReLU 操作。 输入图像包含 1024 个像素（32 x 32 大小），第一个卷积层（卷积层 1）由六个独特的 5x5 （步长为 1）的滤波器组成。如图可见，使用六个不同的滤波器得到一个深度为六的特征图。 卷积层 1 后面是池化层 1，在卷积层 1 得到的六个特征图上分别进行 2x2 的最大池化（步长为 2）的操作。你可以在池化层上把鼠标移动到任意的像素上，观察在前面卷积层（如上图所示）得到的 4x4 的小格。你会发现 4x4 小格中的最大值（最亮）的像素将会进入到池化层。 池化层 1 后面的是十六个 5x5 （步长为 1）的卷积滤波器，进行卷积操作。后面就是池化层 2，进行 2x2 的最大池化（步长为 2）的操作。这两层的概念和前面描述的一样。 接下来我们就到了三个全连接层。它们是： 第一个全连接层有 120 个神经元 第二层全连接层有 100 个神经元 第三个全连接层有 10 个神经元，对应 10 个数字——也就做输出层 注意在下图中，输出层中的 10 个节点的各个都与第二个全连接层的所有 100 个节点相连（因此叫做全连接）。 同时，注意在输出层那个唯一的亮的节点是如何对应于数字 “8” 的——这表明网络把我们的手写数字正确分类（越亮的节点表明从它得到的输出值越高，即，8 是所有数字中概率最高的）。 同样的 3D 可视化可以在这里看到。 其他的 ConvNet 架构卷积神经网络从上世纪 90 年代初期开始出现。我们上面提到的 LeNet 是早期卷积神经网络之一。其他有一定影响力的架构如下所示3： LeNet (1990s)： 本文已介绍。 1990s to 2012：在上世纪 90 年代后期至 2010 年初期，卷积神经网络进入孵化期。随着数据量和计算能力的逐渐发展，卷积神经网络可以处理的问题变得越来越有趣。 AlexNet (2012) – 在 2012，Alex Krizhevsky （与其他人）发布了 AlexNet，它是比 LeNet 更深更宽的版本，并在 2012 年的 ImageNet 大规模视觉识别大赛（ImageNet Large Scale Visual Recognition Challenge，ILSVRC）中以巨大优势获胜。这对于以前的方法具有巨大的突破，当前 CNN 大范围的应用也是基于这个工作。 ZF Net (2013) – ILSVRC 2013 的获胜者是来自 Matthew Zeiler 和 Rob Fergus 的卷积神经网络。它以 ZFNet （Zeiler &amp; Fergus Net 的缩写）出名。它是在 AlexNet 架构超参数上进行调整得到的效果提升。 GoogLeNet (2014) – ILSVRC 2014 的获胜者是来自于 Google 的 Szegedy等人的卷积神经网络。它的主要贡献在于使用了一个 Inception 模块，可以大量减少网络的参数个数（4M，AlexNet 有 60M 的参数）。 VGGNet (2014) – 在 ILSVRC 2014 的领先者中有一个 VGGNet 的网络。它的主要贡献是展示了网络的深度（层数）对于性能具有很大的影响。 ResNets (2015) – 残差网络是何凯明（和其他人）开发的，并赢得 ILSVRC 2015 的冠军。ResNets 是当前卷积神经网络中最好的模型，也是实践中使用 ConvNet 的默认选择（截至到 2016 年五月）。 DenseNet (2016 八月) – 近来由 Gao Huang （和其他人）发表的，the Densely Connected Convolutional Network 的各层都直接于其他层以前向的方式连接。DenseNet 在五种竞争积累的目标识别基准任务中，比以前最好的架构有显著的提升。可以在这里看 Torch 实现。 总结在本篇文章中，我尝试使用简单的方式来解释卷积神经网络背后的主要概念。我简化/跳过了一些细节，但希望本篇文章可以让你对它们有一定的了解。 本文最开始是受 Denny Britz 的理解用于自然语言处理的卷积神经网络（我强烈建议阅读）启发，大量的解释也是基于那篇文章。如果你想要对这些概念有更深的理解，我建议你浏览一下 Stanford 的 ConvNet 课程中的笔记，以及下面所列的参考文献。如果你对上面的概念有什么疑问，或者有问题和建议，欢迎在下面留言。 本文中使用的所有图像和动画的版权都归下面参考文献中对应作者所有。 参考文献 Clarifai Home Page Shaoqing Ren, et al, “Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks”, 2015, arXiv:1506.01497 Neural Network Architectures, Eugenio Culurciello’s blog CS231n Convolutional Neural Networks for Visual Recognition, Stanford Clarifai / Technology Machine Learning is Fun! Part 3: Deep Learning and Convolutional Neural Networks Feature extraction using convolution, Stanford Wikipedia article on Kernel (image processing)) Deep Learning Methods for Vision, CVPR 2012 Tutorial Neural Networks by Rob Fergus, Machine Learning Summer School 2015 What do the fully connected layers do in CNNs? Convolutional Neural Networks, Andrew Gibiansky A. W. Harley, “An Interactive Node-Link Visualization of Convolutional Neural Networks,” in ISVC, pages 867-877, 2015 (link) Understanding Convolutional Neural Networks for NLP Backpropagation in Convolutional Neural Networks A Beginner’s Guide To Understanding Convolutional Neural Networks Vincent Dumoulin, et al, “A guide to convolution arithmetic for deep learning”, 2015, arXiv:1603.07285 What is the difference between deep learning and usual machine learning? How is a convolutional neural network able to learn invariant features? A Taxonomy of Deep Convolutional Neural Nets for Computer Vision Update At 2017年6月23日 感谢 Annie 指出错误。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「效率工具」一个指令搞定 Bilibili 和 Youtube 视频下载]]></title>
    <url>%2F2019%2F07%2F21%2Fbilibili-youtube-download%2F</url>
    <content type="text"><![CDATA[一个简短快捷的指令，冲破屏障，化腐朽为神奇。 做法与之前的文章《一个指令搞定百度文库》类似，不需要下载任何软件。 Bilibili打开任意一个 Bilibili 视频，点击地址栏，在“bilibili”前加上字母“i”。 在新出现的页面中右击视频，下载视频。 Youtube打开任意一个 Youtube 视频，点击地址栏，将“youtube”中的“ube”删除。 在新出现的页面选择视频下载，也可以只下载音频。]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「效率工具」奶牛快传，文件传输神器]]></title>
    <url>%2F2019%2F07%2F07%2Fraw-transfer%2F</url>
    <content type="text"><![CDATA[目前常用的传文件方式存在以下痛点： 微信文件限制 100M 大小 网盘限制上传和下载速度 QQ 几乎没人用了（工作环境） 邮件在移动端接收不方便 奶牛快传很好的解决了以上问题。 工具以网站的形式存在，因此只要设备有浏览器即可使用。 同时有微信小程序版，更好适应微信生态。 速度方面，无论是上传还是下载，均无速度限制，完全依赖于用户宽带。 交互方面，操作界面极简，界面中心只留了一个大按钮，添加文件后，文件会被快速上传，随后生成该文件的下载链接、二维码及小程序码。 文件方面，普通用户一次性可传输 4G 大小的文件，文件保存72 小时，注册用户可保存 165 小时文件保存，足够日常的使用。 网站链接：http://cowtransfer.com/]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业感悟]]></title>
    <url>%2F2019%2F06%2F17%2Fgraduate-thinking%2F</url>
    <content type="text"><![CDATA[这几天依然沉浸在离别的悲伤中无法自拔，每天的午睡都处于混沌梦境之中，仿佛越陷越深。作为最后走的一个人，送走了一位位同学，现在人去楼空，面对空荡荡的走廊与房间，不禁心生悲凉，五味杂陈。 大学四年，终于还是来到了毕业这一天。毕业酒会上，微醺的我没绷住，情绪失控，抱着同学嚎啕大哭。四年的感情化作泪水，宣泄出来。四年大学生活要告一段落了，人生就是这样，一次次幸福的相聚，夹杂着一次次痛苦的别离。 现在的我正收拾心情，写点东西，稀释一下这些天积淀的情绪，开始向前看。 高中时，我就一直幻想着大学生活，或惬意、或自由，也一直期待着度过一个有意义的大学生活，要对得起自己的青春。因此在上大学前，就决定在大学干一些有意义的事： 拿一次奖学金 培养自己的兴趣爱好 谈一次恋爱 四年过去了，拿了四年的奖学金，学会了吉他，谈了一次不是恋爱的恋爱。但现在，我不禁反问自己，这样就算有意了义么？ 有一位博士在他的论文致谢中这样写到： 从进入大学到博士毕业，整整十年了。在这十年中，我过得浑浑愕额。 十年前，我身高170cm，十年后，我身高还是170cm。 十年前，我体重60kg，十年后，我体重还是60kg。 十年前，我一无所有，十年后，我还是一无所有。十年前，我眼睛明亮、有神，十年后，摘掉眼镜，我已看不清自己有多少个手指了。 十年前，我声音洪亮、清澈，十年后，已经是慢性咽喉炎，声音嘶哑。 十年前，我踌躇满志、指点江山、激扬文字，十年后，我心如止水，只求温饱。 当然，我也得到了一些东西。 十年前，我还是个农民的儿子，十年后，我成为了一个博士。 十年前，我只懂得砍柴、种田、割草、放牛，十年后，我已经成为了一个懂机械、金融、管理的复合型人才。 但如果您问我这十年最大的长进是什么，我将告诉您：十年前，我十七，十年后，我二十七。 上面的致谢，作者表达了自己的无奈。和大多数人一样，我们更多的只是学习课本的理论知识，实践经验少之又少，毕业之后面临融入社会的问题，似乎四年下来，只有年龄长了4岁，其他的一无所获。 因此如果现在有人问我，大学应该干些什么，我想我会更加具体的告诉他：驾照，专业证，四六级，坚持锻炼，交点好朋友，多去上课，多看书看好书，多去图书馆。学会独立思考，尝试多点事情不会后悔，尊重别人，懂得感恩，学会与自己相处。还有重要的一点，就是多实践。 经过四年的观察，发现在大学，似乎也有一个约定俗成的二八定律：假如你比别人努力20%，那么你将超过学校80%的人。 在大学，有的人努力创业，实现某种程度上的财务自由；有的人努力学习专业知识，拿到奖学金，找到满意的工作或继续深造；有人努力做学生工作，提高锻炼自己的口才和能力。 当然，学历或者在校的成绩并不能说明什么，步入社会后也将面临更多地机遇和挑战，但相信大学努力过的你至少成长过，与过去的自己相比应该是更好了。就像之前听到过的一句话：如果你和别人比自己就像个弱鸡，那你就和过去的自己比，现在的自己是否比过去的自己更好。 大学里拿到多好的成绩、多少的奖励或许都不重要，自己是否独立、是否成长、是否能在未来的工作或者生活中独当一面，或许这才更加重要。正如我在论文致谢中所说，大学，其实就是学着长大。 花有重开时，人无再少年。总之大学时光就这样过去了，随之而来的是两年研究生生涯，未来充满变数，今后的生活中，我依然会做好这几点： 坚持锻炼注意饮食，维护好身体 多结交优秀的人，以他们为榜样 学会感恩 人总是要向前看的，活在当下，学会放下，美好的回忆放在盒子里，想起时打开看看。希望老师同学一切安好，我不是在最好的时光遇见了你们，而是遇见了你们，我给了我这段最好的时光。未来可期，我们江湖再见！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的论文致谢]]></title>
    <url>%2F2019%2F06%2F06%2Fmy-paper-thanks%2F</url>
    <content type="text"><![CDATA[) 时光荏苒，四年大学时光若白驹过隙，忽然而矣。作为软件学院的一名学生，我更愿意把大学生活比作一段程序。从进入校园开始，我们输入“Hello NCHU”的命令，程序便开始运行起来。每段程序或多或少都会有一些bug，通过不断的学习，不断的修复自身才使得代码更加的健壮，而我们也在百般洗礼中不断成长。所谓大学，其实就是学着长大。 我要感谢南昌航空大学，感谢学校的一花一草一木，让我能够沉浸在鸟语花香中汲取知识。感谢图书馆，虽然我走了就开始翻修，但三年里依然是我的精神家园，见证了我的成长。感谢食堂手有点抖的大妈，做出美味又便宜的食物。感谢宿管大爷，每天准时锁门提醒我早点回寝休息。感谢软件学院足球队，与他们一起训练踢球很开心。感谢教官队，磨练了我的意志，让感受到责任与义务。感谢162042班的每位学员，他们都很有个性，与他们打交道也让我学到了很多。感谢152021班的所有同班同学，做为班长可能还不够尽职尽责，感谢他们的包容与理解！ 我要感谢软件学院的每一位老师。感谢班主任代红老师和辅导员温老师，两位都是非常负责任的老师，把每位同学当作自己的孩子一样看待，在生活上与学习上给予我们帮助。我要感谢杨丰玉老师，杨老师是我大学的启蒙老师，老师为我制定学习计划，带我做项目，让我的专业技能可以快速提高。感谢我的论文指导老师仲颢博老师对我耐心指导和帮助，为我答疑解惑并提出宝贵的建议。感谢东软班潘志园老师，让我们能够快速适应东软的生活。感谢段喜龙老师、樊鑫老师，还有瓦师傅，感谢所有教过我的老师们，他们有的严厉，有的风趣，但都教会我很多，这里由衷的感谢！ 我要感谢我的几位室友，他们陪伴了我大学整整四年，我们一起熬夜写代码，一起去图书馆学习，一起开黑玩游戏，一起看电影，一起吃火锅，一起游泳，一起单身。曾经的欢乐时光仿佛历历在目，认识你们真好，以后江湖再见！ 我要感谢我的父母赋予我生命，让我来到这个多姿多彩的世界，他们辛劳付出，勤俭节约，供我吃穿，让我能够茁壮健康地长大，让我能够有机会进入大学，让我能够心无旁骛地完成学业。我也要感谢我的妹妹，她的到来让家里充满生气与欢笑，希望哥哥能够成为她的榜样。再次感谢我的家人们，让我能感受到亲情的温暖，他们是我最坚实的后盾，Love you three thousand！ 最后，感谢努力的自己。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 2019 小结]]></title>
    <url>%2F2019%2F05%2F08%2Fgoogle-io-2019%2F</url>
    <content type="text"><![CDATA[Google I/O 2019 大会于北京时间 5 月 8 日凌晨 1 点，在美国山景城 Shoreline Amphitheatre (圆形剧场) 举办。今天熬夜看了直播，这里对大会的 keynote 进行一个小结。 去年的这个时候，同样对大会进行了一个小结，感兴趣的可以看一下文章进行一个对比。 一年过去了，Google 在那些方面有了新的进展呢，一起来看看吧。 Google Search 引入更强大的视觉能力，使用 AR，将搜索结果进行 360˚ 全景展示 Google Lens 更强大的识图能力，拍菜单，显示大众点评高赞菜品，拍小票，自动计算金额和小费 与地图、翻译以及其他应用结合 Google Go 拍照识字并朗读，帮助不识字的人群 包含印地语、中文在内的10多种语言 Google Assistant 扩展到网络上，叫做 Duplex on the web 理解日历行程信息、Gmail 邮件内容，自动在填写订单时补全信息 持续对话，不用一直 hey google 识别速度更快 可以在不同应用内操作任务 Live Relay 语音识别和 TTS（文本转语言），帮助聋哑人士接电话。 智能回复建议，不开口就能打电话。 Android Q 更注重隐私 加入全局“黑暗模式” 适配折叠屏 Wifi 分享、优化系统手势交互 Pixel 3a 价格亲民 依靠算法，单摄吊打 iPhone X 更长的续航，充一次电可使用 30h 带 3mm 耳机接口 Nest Hub 带屏智能音箱 加入手势识别，抬手停止音乐 人脸识别，千人千面，针对家庭不同成员进行不同的内容展示 打电话、播放谷歌相册，以及 YouTube 节目。 Google AI 推进医疗研究，筛查早期肺癌，提高患者生存率 AI预测洪水，规划排水渠道 最后，所有新的产品都离不开 AI，Google 这样伟大的一家公司正使用 AI 改善用户体验，造福人类，这也是 Google 一直以来提倡 AI for social Good 的理念成果。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gmail 无限衍生]]></title>
    <url>%2F2019%2F05%2F07%2Fgmail-infinity%2F</url>
    <content type="text"><![CDATA[这应该是一个比较老的话题了，但信息差总是会有的，这里进行科普一下。 好处目前还是有很多网站使用邮箱验证，因此可以通过邮箱衍生来注册多个账号。另外，也可以用来管理邮件列表，辨别邮件来源。 邮箱别名Gmail的无限衍生其实是利用的邮箱别名，可以通过以下规则得到无限的谷歌邮箱别名。 这里以邮箱abcdef@gmail.com为例，以下示例均指向同一邮箱。 1、用户名之间加 “.” a.bcdef ab.cdef abc.def abcde.f 此用途主要是针对外国名字的，用于名和性的区分。 2、用户名后面加 “+” abcdef+weixin abcdef+baidu abcdef+qq etc. “+” 号后面可添加任意字符，可用于区分邮件来源，这样就知道那个网站给你发垃圾 / 广告邮件了，方便拉黑。 3、把后缀变为 googlemail.com 例如：abcdef@googlemail.com 4、以上三种结合使用 例如： abc.def+qq@googlemail.com 最后以上无需到 Gmail 设置，注册时直接填写变形的邮箱即可，不同的变形地址都是会在同一个收件箱出现的。 最后，问题来了，如何上网注册一个 Gmail 呢？]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>Gmail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬取小程序接口图片]]></title>
    <url>%2F2019%2F03%2F21%2Fpython-get-mp-pic%2F</url>
    <content type="text"><![CDATA[Python 爬取小程序接口图片之前我开发过一个「校徽头像制作」的微信小程序，目前陆陆续续添加了有几百来所高效校徽，用户数也有 1w+ 了。 校徽之前都是自己手动一个一个添加到服务器的，效率很低，导致如今都还有很多校徽缺失，体验不好。 这几天偶然发现了另外一个小程序，里面的校徽图片很齐全，于是决定爬一爬。 反编译小程序要爬小程序里面的数据，需要知道小程序的接口地址以及参数。反编译小程序的主要目的就是是看到的 JavaScript 代码，这样就可以知道网络请求的 URL 以及 参数名称。 反编译小程序的过程比较复杂，这里可以直接参考文章：只需两步快速获取微信小程序源码^1。 最后，我在代码中获取到如下关键信息： 1234567const url = `https://api.iamsaonian.com/index.php`；const param = &#123; 'm': "Api", 'c': "Xiaohuiavatar", 'a': "xiaohui_list", 'p': page&#125; 在 Postman 中进行请求，接口数据格式如下图，十分标准的 Json 格式数据，并且进行了分页。 下面就可以动手去爬去数据，并下载图片了。 爬取图片首先说一下爬取思路，请求上面的接口，并解析数据，获取图片的 URL，下载图片，保存 csv 格式数据。 使用到的包有下面几个： 1234import jsonimport urllib.requestimport requestsimport csv 使用 urllib 下载图片至本地，图片命名使用 id 命名。 12345# 获取图片格式str_array = logo.split('.')format = str_array[len(str_array) - 1]# 通过urllib.request下载图片到本地urllib.request.urlretrieve(logo, '本地地址'+id+'.'+format) 打开填写的地址，图片下载到了本地，共有 2728 个校徽图片。 保存数据以后想使用云开发重构小程序，因此将数据保存为 csv 格式，便于数据的插入。 123456789# 将数据保存为 csv 格式with open('logo.csv', 'w', newline='', encoding='utf-8') as csvfile: # 设置表头 fieldnames = ['id', 'name', 'logo'] # 获得 DictWriter对象,使用，号分隔，便于云数据库导入 dict_writer = csv.DictWriter(csvfile, delimiter=',', fieldnames=fieldnames) # 第一次写入数据先写入表头 dict_writer.writeheader() dict_writer.writerows(list) 打开小程序云开发控制台，选择数据库，导入本地 csv 数据，这里我已经将爬去的数据导入到云开发数据库了。 在公众号对话框回复「爬取校徽」可获取本次文章的代码以及校徽图片。 欢迎加我微信，一起交流，互相学习，共同进步！ 关注公众号『嗜码』。回复关键字「前端」、「Python」、「Java」、「Android」、「小程序」、「Vue」等获取免费精品学习资料。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己对考研的理解]]></title>
    <url>%2F2019%2F03%2F14%2Fthoughts-about-kaoyan%2F</url>
    <content type="text"><![CDATA[今天分享一篇考研相关文章，送给正在努力备考的同学，希望有所帮助。文章已获得作者：@Faded 授权。 本科双非，19 考研，一战华南理工，失败。从 3 月份开始备战，10 个月的考研有得有失，总结一下希望给后来人一点借鉴。 1、定位19 考研人数又创新高，可以预见：未来几年人数必将继续增加，考研热会持续升温。19 年国家整体报录比为1:4，除部分冷门专业，985/211 高校的竞争会远远超过此比例。 考研中最重要的是认清自己，找准自己的定位。 考研目的是为了从事科研还是想镀金方便工作赚钱？将来所想从事的行业是否对学历有硬性要求？本科出身如何？自己在大学四年中的表现如何？自己有没有相关的资源？ 考研是提升自己阶层的宝贵通道，人人都想鲤鱼跃龙门。但是看看热门高校的报录比、录取线，简直就是神仙打架，炮灰多的惨不忍睹。考研不同于高考，付出产出比只有 100% 和 0%。 有些人有名校情结可以理解，但有些人明明知道自己的复习程度和智力水平最后还硬刚，真心觉得不理智。选择名校所承担的心理压力以及因此产生的复习效率、临场发挥等，都要权衡一下。一般名校的专业科难度较高，复习期间必然会比普通高校分配更多的时间给专业科。 定位高校的时候给自己留条后路，很多高校的专业课是类似的，给自己做好预案，万一到了 10 月份觉得没复习太好，立马换个档次。这个时候，选择比努力重要太多了。 每年的调剂，咦~~~真香 2、态度如果你选择好了高校，那么就大胆的上吧。 摆正自己的态度。都说学习是努力和智力的结合，但很多人的努力程度还没到了需要拼智力的时候。 考研期间卸载手机中的无关APP（追剧类软件、抖音微博、各种游戏）。这些软件会无形中占用大量时间、分散人的精力。学习期间不要玩手机，如果做不到，建议不要带手机去学习。放心，没了你，地球照样转。可以每天抽出固定的时间玩玩手机，搜集信息以及娱乐。自制能力弱的人，推荐读一读 凯利•麦格尼格尔 的《自控力》。可以找研友互相监督、共同进步（建议研友1-2名即可）。 制定合适的作息时间，然后严格执行。尽量不要给自己开小灶，人都是有惰性的，有些事情有第一次便会有第二次，断绝各种给自己开小灶的借口，有时候挺一挺就过去了，没那么难。学习效率需要规律的作息来保证， 建议每周给自己腾出专门的休息时间，要休息就好好休息，要学就专心的学。每天都扑倒学习上，可能后期身体吃不消，而且更容易放大压力。 放松最好的方法就是睡觉，不是玩手机，不是打游戏，不是刷视频。学习累了就给自己放个假，适当的锻炼，好好的睡一觉，睡饱了继续干！考研期间社交该停的停，该推的推。情侣们体谅一下，都省点心，吵架闹矛盾真的影响。 考研尽量保持心态的平稳，这个很难，大多数人的心态是起起伏伏的，甚至可能考研的成败取决于最后的心态。尽人事知天命，当压力大时，列出一些自己可以做的事（影响圈），尽全力把这些做好，你只可能改变这些事情。影响圈之外的东西是你无法改变的，或好或坏你都要学会接受，学会妥协。人生不如意之事十之八九，能与人言事不足十之一二。 3、跑步强烈建议每天挤出一点时间来跑步。身体是革命的本钱，有个好的身体是最大的资本。每天跑步可以增强身体素质，提高学习的效率。尤其到了考研后期，进入秋冬季节容易感冒发烧，这时如果身体出现毛病，可是要了老命了。 考研后期会有很大的心理压力甚至焦虑，跑步之类的有氧中低强度锻炼可以提高情绪，身体也会在这样的运动过程中释放让人感觉良好的内啡肽和去甲肾上腺素。另外，跑步对于下肢、肩背等也有好处。 当然，也可以按照个人的爱好，来选择合适的锻炼项目。不过跑步不需要太多的器材，比较方便。对于时间宝贵的考研人来说，跑步是最好的选项。 4、方法对于各科的学习方法，请移步知乎。各路神仙大佬数不胜数，可以借鉴一下。此处简单介绍一下我的理解：不管是啥科目，进度尽量提前，充足的时间可以让你在后期查漏补缺。可以多和同学交流一下方法，多尝试一些方法。感觉所以科目都应该以真题为主，多刷几遍，这个太重要了。 数学本人爆炸，不做介绍。 本人大学英语渣渣，但觉得英语最重要的熟读历年真题。语法啥的有点基础知识就行，还是单词比较重要。个人认为单词书看看就好，别太花心思（9月份才领悟，惨）。英语推荐唐迟老师的阅读，掌握阅读技巧太重要了（11月中旬才领悟，惨惨…）,在阅读中记单词比较好。英语作文不建议看视频，感觉没啥用，直接背范文得了。最后总结出一些自己的模板，土豪可以直接购买私人模板。 政治推荐徐涛（因为看肖的视频太困），政治当成小菜，可以当个相声缓解一下，背一背风中劲草对选择题很有帮助。大题的话背肖四肖八（肖四全背，肖八看一看读一读）。政治建议早点开（7月末），每天在数学间隙看看就好，到了最后再发力。 5、复盘在考研期间，建议半个月左右进行一次复盘。对各科的学习进度和学习方法进行调整，也可以对各科进行思维导图式的总结，形成自己的知识框架体系。知道一个东西和把这个东西说出来、讲清楚是两码事，倒逼自己输出，可以更清楚的知道自己会什么、不会什么。]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软推出了哪些好用的微信小程序]]></title>
    <url>%2F2019%2F02%2F23%2Fmp-about-microsoft%2F</url>
    <content type="text"><![CDATA[说起微软，大家可能对其 Windows 操作系统以及 Office 办公软件非常熟悉。但是在移动端，微软产品的市场占有率却少之又少。随着微信小程序的兴起，微软也乘势推出了几款好用小程序，让用户更加快捷地在手机上享受到微软科技带来的便利。 微软AI识图原名「微软小蜜」，后更名为「微软 AI 识图」，是微软中国首款微信小程序。它运用微软多年研究图片的认知能力，通过识别图片，提取图片信息，可智能生成 Office 文档。目前拥有拍图识字，高度还原表格，人脸识别制作文档，拍照翻译，拍照转 PDF/PPT 五项能力。 微软 Office 文档Office 365 在移动端有独立的 App，但是大小动辄数十M ，使得一些内存较少的手机运行起来非常吃力。因此如果是 Office 365 用户，推荐使用「微软 Office 文档」小程序。小程序能够帮助 Office 365 用户在微信中随时浏览、编辑和分享 OneDrive 中的 Office 文档，方便快捷。 微软听听文档有时候我们习惯在微信群中讨论某一观点，铺天盖地的图片、文件和语音难免会刷屏般的聚集在微信群聊中。微软推出的这一款「微软听听文档」小程序便能够很好的解决这个问题。你只需要打开小程序，并创建一个语音文档，将你的图片添加进去（也可以直接导入 PPT），便可以对每张图片进行语音解释。 完成你的录音之后，只需要点击分享按钮，输入文档标题与权限，最后就可以生成语音文档分享在群内，与群内好友共同讨论。 微软海报这款小程序的名字跟功能没什么关系，它并不是用来制作海报，而是用来创作小视频的。可一秒生成抖音同款照片电影、单图剪切九宫格、转场动画、各种滤镜音效，同时可蓝光画质转发好友。 每日英语电台每日英语电台是一款有 ChinaDaily 和微软亚洲研究院联合推出的小程序产品，提供了英语阅读以及听力能力。小程序提供新闻给大家阅读，点开文章之后，可以直接点词查看翻译，还可以收藏文章下次学习，对不认识的单词可以添加到单词本，是一个非常好用的英语阅读小程序。 单词闪猜这也是由微软亚洲研究院开发的一款有意思的小程序，玩法有点类似于 Google 的 「猜画小歌」。小程序以游戏的方式，让用户使用英文描述出所给单词，AI 来猜，旨在帮助用户提高英语应用能力。例如给出单词「Bill Gates」，我使用「A man who built Microsoft corporation.」，AI 便很快能够猜出我所描绘的单词。 以上就是微软推出的好用的小程序，直接在微信搜索相应的小程序目名称即可获取使用。各位有好用的工具也可以留言告诉我哟～]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三个有用的图片工具网站]]></title>
    <url>%2F2019%2F02%2F20%2Fpicture-tool-site%2F</url>
    <content type="text"><![CDATA[1、remove.bg看名字也能猜出来网站的功能，网站利用图像识别技术，检测人像区域，去除图片背景，实现自动快速抠图。搞过 PS 的人都知道，抠图比较难的应该就是人像图片了，尤其是头发部分。这里传了一张人像图片，可以看出效果还是提不错的。另外，网站也提供第三方的接口，可以在自己的代码中使用。 网站链接：https://www.remove.bg/ 2、photomosh《银翼杀手》、《攻壳机动队》等科幻电影构建了一个风格独特的赛博朋克（Cyberpunk）世界，也催生了一种名为故障艺术（Glitch Art）的设计风格，近年越来越受到设计师的追捧。PhotoMosh 工具中就提供了这种故障特效，能够方便快捷的生成很多故障特效图片。 首先根据提示选择一张本地图片，网页右侧会生成相应的特效选项。常用的有像素模糊、RGB 偏移、波纹、摇晃等等基本特效，还有其他一些非常酷炫的特效可供选择，所有的特效可以叠加使用。下面图片是生成效果，感觉还不错，可以导出为图片、GIF以及视频格式。 网站链接：https://photomosh.com/ 3、Algorithmia网页可以自己上传图片或者输入图片 URL，经过分析后，生成上色的图片。例如这里使用的一张图片，可以看到网页能够辨别出图片中的物体，并加上相应的颜色。例如天空则填充蓝色，山脉则填充黄白色，植被填充相应的绿色，还有对阴影处理得非常到位。 图片上色只是是这个网站的一个小功能，其他相关功能有例如：图片标签、图片物体识别等等，并且网站提供第三方接口，可以在自己的代码或者应用中接入。 网站链接：https://demos.algorithmia.com/colorize-photos/]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一封「导师体验」良好的简历邮件]]></title>
    <url>%2F2019%2F02%2F19%2Fwrite-right-email%2F</url>
    <content type="text"><![CDATA[大部分考研的同学已经查到了自己的成绩，持续数月的备考与等待也有了结果。看着朋友圈的喜怒哀乐，庆幸自己早一步上车。 成绩理想的同学可以开始着手接下来的复试，没有考好的同学也务必调整好心态，做好工作 or 二战的打算。 书归正传。在查到自己的成绩后，联系导师这个操作少不了。与导师素未谋面，电子邮件是与导师交流沟通较为妥当的方式。因此，电子邮件可能会成为导师对你的第一印象，写一封「导师体验」良好的邮件非常重要。 先说一下，这里只在邮件注意事项上给出若干建议，简历邮件内容还请移步各大考研论坛参考模板。另外，或许这是你第一次撰写电子邮件，万事开头难，希望以下内容对你有所帮助。 1、确保导师能够收到邮件确保你的邮件能够毫发无损地到达收件箱，而不是被系统归到垃圾邮件，这是一个大前提。否则简历再优秀，邮件再生动，也是徒劳。以下是几点建议： 使用市面上较为常用的邮件服务提供商。例如 Gmail，163 邮箱，QQ 邮箱等。 编写有意义的标题，正文避免包含链接。 看看导师使用什么邮箱，自己也去注册一个。然后尝试自己向自己发送邮件，看是否能够接收。 2、导师是否查看邮件如何知道导师是否查看邮件？我们可以掌握主动权，而不是陷入盲目的等待。 这里推荐一个 Chrome 浏览器插件：mailtrack，可用于邮件追踪。如果你使用的是 Gmail，插件会提示你的邮件是否送达，以及收件人是否查看和查看次数。 如果使用 163 邮箱或者 QQ 邮箱，发送邮件时可以勾选底部「已读回执」选项，收件人查看邮件后系统会发送回执到你的邮箱，提示邮件被打开。 不过并不建议你使用回执，因为现在的邮箱都无法强制发送回执，而是需要收件人的确认，例如 QQ 邮箱中的提示。 这是否会产生视觉上的干扰，是否合适，还请大家斟酌。 3、取好邮件标题标题是导师进入邮箱第一眼看到的东西。上面说到，编写有意义的标题，否则系统很大程度上会将你的邮件归为垃圾邮件。同时，你需要让导师一眼就知道邮件目的，而不是直接忽略，因此你可以这样：【研究生申请】xxx 大学 xx 学院 xxx。 值得注意的是，如果你使用的是 QQ 邮箱，还请修改一下自己的默认帐户昵称（设置-账户中修改）。否则，导师收到的邮件可能是这个样子的。 非主流的昵称、回忆杀？是否让导师也想起逝去的青春？ 哈哈，为了显得较为正式，建议暂时将昵称改成自己真实的名字，正经一些不好吗？ 4、写好正文正文是你整封邮件的排面，排版是否整洁，字体以及字体大小、颜色是否统一，段落是否鲜明等等都是需要注意的。先放张图对比一下，如果你是导师，你更愿意阅读哪一封呢？ 正文板式，其实越简单越好。邮件正文不要使用任何背景图片、音乐，同时避免使用不同颜色、大小、字体进行排版。如果需要对内容进行强调，简单加粗就行。注意分段，文字不要堆在一块，一段文字一般不要超过十行，否则会引起视觉疲劳。 对于内容，检查是否有错别字，标点符号是否使用正确，语言是否通顺。同时，邮件里可能会提到一些专有名词，请务必核实，体现自己对学术的严谨性。例如对于编程语言中的英文名词，使用 Python 而不是 python，使用 Java 而不是 java，使用 Android 而不是 android 等等。 最后，尽量考虑到导师的阅读场景，电脑 or 手机。因此，建议先给自己发一封，并分别在电脑和手机上打开，看字体大小是否合适，阅读体验是否良好。 5、附件相关如果邮件自述中叙述的不是太有条理，建议制作一份简历作为附件发送。而你的简历附件容不容易打开，命名是否有意义，这是需要注意的。 有些同学一个简历打个压缩包，导师需要下载解压查看，操作成本太高。有些同学使用 WPS、Word 格式的附件，但没有考虑到导师没有安装办公软件，或者手机上查看等一系列场景。因此简历附件建议转换统一成 PDF 格式，这样即使不下载任何办公软件也可以打开，同时支持在线预览。 最后很关键的一点养成正确的发邮件流程，插入附件——复查附件——撰写正文——拟写标题——填上收件人，这样就能避免附件忘记插入、附件发错、标题忘记写的情况。 6、小结以上就是联系导师邮件等相关注意事项以及建议，希望对大家有所帮助。这里引用 Fenng 大文章中的一句话，怎样算是「用户体验」良好？就是你做的事情必须为对方考虑，而且，你的确考虑到了。 有的时候，我们把为对方考虑这种行为，也叫做同理心。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>研究生</tag>
        <tag>经验</tag>
        <tag>感悟</tag>
        <tag>邮件</tag>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网 B 哥直播总结]]></title>
    <url>%2F2019%2F01%2F13%2Fthoughts-about-b-ge-live%2F</url>
    <content type="text"><![CDATA[昨天观看了互联网B哥(stormzhang，下文以张哥做称呼)的直播，对直播内容进行一个总结，也是为了让自己加深印象，或许会对大家有所启发。 学习张哥首先提到学习，学习不应带有功利性，不要想着学了就会有所收获，要有延迟满足的心态。利用碎片化时间，养成习惯，慢慢积累，量变引起质变。至于学习，把80%的经历投入到本专业工作中，20%的精力投入到自我提升方面。 圈子圈子很重要，不同的层次，有着不同的思维，可以看到不同的世界。在一个领域待久了，容易固化，去其他圈子看看，向不同领域的人学习，但是提升的本质在自己。抱着虚心学习的态度加入圈子，而不是以为加入圈子就飞黄腾达了。 信息差罗胖在跨年演讲也提到了信息差的概念：在中国，再普遍的常识，也至少有一亿的人不知道。因此有人会揣摩信息，利用信息差生意，从中牟利。例如有人付费开通微信支付分，有人付费找论文代写中介等等。 预测 产品。头条可能成为新的巨头，产品覆盖从1线到18线城市。即将推出新的社交产品，对标腾讯，保持关注即可 5G。19年5G还很难做到普及，但是会进入大众视野，会改变很多方面。首先是手机厂商，又有理由让大家换新的手机。其次，由于网速的提升，在物联网、智能家居、无人驾驶方面会带来较大的影响 消费。现在的年轻人的消费观念与上一辈有很大的差别，上一辈吃饱穿暖，年轻一辈追求生活的品味与质量，更多的是精神层次的享受。例如在看电影，购物等等的方面。 行业。在线教育是朝阳行业，去年有一篇很火的文章，讲的就是一块电子屏幕让山区的学生能够接收与城市学生同等水平的教育。正是有了在线教育，缩小了教育水平的差距，使得教育更趋于公平化。另外，知识付费在2018年兴起，今年也将持续发展。往广了说，知识付费也是一种在线教育。 更远的发展。AI会对很多行业产生冲击，需要掌握AI不能替代的能力。 其他内容张哥主要是对自己的一个复盘，这里就不在赘述，希望以上内容对大家有帮助或者启发。当然，不一定说了解趋势或者不断学习就能怎样怎样，理都懂，关键还要看自己的洞察力以及执行力。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>感悟</tag>
        <tag>总结</tag>
        <tag>B 哥</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序使用 ES6 新特性]]></title>
    <url>%2F2019%2F01%2F04%2Fmp-es6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。 小程序在很久之前就支持了ES6了，因此在小程序的开发中，我们可以适当的使用ES6中的一些新特性，来简化代码，高效开发。 在使用微信开发者工具调试之前，记得先勾选上es6转es5选项，这样工具才会将es6语法进行转换。 1、模板对象模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，这样就避免了使用大量的(+)来拼接字符串。例如下面的代码： 123456var wechat = '1349571206zmy';var qq = '1349571206',// es5console.log('my wechat is ' + wechat + ' and my qq is ' + qq);// es6console.lg(`my wechat is $&#123;wechat&#125; and my qq is $&#123;qq&#125;`); 2、默认参数在es6中，函数可以有默认的参数，这样就避免了认为的对参数进行判空或者其他处理。例如下面代码，封装了微信小程序原生的toast，默认传入title参数即可。123456789101112131415/** * 显示toast * @param &#123;string&#125; title toast标题 * @param &#123;string&#125; type toast类型 * @param &#123;number&#125; duration toast时长 * @param &#123;boolean&#125; mask 是否显示遮罩 */showToast(title, type='none', duration=1000, mask=false) &#123; wx.showToast(&#123; title: title, icon: type, duration: duration, mask: mask &#125;);&#125; 3、类ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。例如定义一个基础类，来封装微信小程序常用的方法，让代码有更高的复用性，也使代码更加简洁。与传统语言相似，支持继承。 1234567891011121314151617// base.jsclass Api &#123; // 显示toast showToast(title, type='none', duration=1000, mask=false) wx.showToast(&#123; title: title, icon: type, duration: duration, mask: mask &#125;); &#125; // ... // 导出 export &#123; Api &#125;;&#125; 定义好类后，可以在其他的js中进行调用。 123456789// index.js// 引用import &#123;Base&#125; from 'base';const base = new Base();// ...// 在函数中调用onLoad() &#123; base.showToast('toast');&#125; 4、解构赋值结解构就是按照一定模式，从数组和对象中提取变量进行赋值，通过解构我们可以让赋值更优雅便捷。例如下面的代码： 12345678// options=&#123;wechat:134957126zmy, email:phillzou@gmail.com&#125;onLoad(options) &#123; // es5获取值 let wechat = options.wechat; let email = options.email; // es6获取值 let &#123;wechat, email&#125; = options;&#125; 5、箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 123456// es6var sum = (num1, num2) =&gt; num1 + num2;// es5var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 6、使用promise简化回调小程序中的api几乎都是回调函数的方式，因此经常会照常回调里面嵌套回调的情况，这使得代码难以理解，因此可以通过promise简化回调。举个简单的例子，小程序中的图片上传。使用小程序进行图片上传的传统方式一般分为这几个步骤： 拍照或者选择相册中的图片 请求后台上传接口 提示上传成功 这样的一个步骤下来，看看代码会变成什么样子。 12345678910111213141516171819// 选择图片wx.chooseImage(&#123; success: (res)=&gt;&#123; // 上传图片 wx.uploadFile(&#123; url: 'serverUrl', filePath: res.tempPath[0], success: (res)=&gt;&#123; // 提示上传成功 wx.showToast(&#123; title: '上传成功', success: (result)=&gt;&#123; // ... &#125; &#125;); &#125;, &#125;); &#125;,&#125;); 可以看到，上面的代码由一个个回调函数嵌套，这使得代码非常难以阅读，下面来看看如何使用es6中的promise进行简化。 1234567891011121314151617181920212223// 选择图片chooseImage() &#123; return new Promise((resolve, reject) =&gt; &#123; wx.chooseImage(&#123; success: (res)=&gt;&#123; resolve(res); &#125;, &#125;); &#125;);&#125;// 上传图片uploadFile(url, path) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.uploadFile(&#123; url: url, filePath: path, success: (res)=&gt;&#123; resolve(res); &#125;, &#125;); &#125;);&#125; 上面的代码将微信小程序api进行封装，并以Promise对象的形式进行返回。当我们真正进行图片上传时，可以这样操作。 1234567this.chooseImage() .then(res =&gt; &#123; return this.uploadFile(res.tempPath[0], 'serverUrl'); &#125;) .then(res =&gt; &#123; return this.showToast('上传成功!'); &#125;) 上面的代码就非常的清晰，以链式调用的方式，能够使人清楚的知道代码的每一步的作用。当然，这里只是介绍了promise在小程序中的一种应用，具体在ES6中的用法还请移步ES6文档。 总结上面只是介绍了es6特性在小程序中的应用，并没有对特性进行深入，希望能增加大家对小程序的了解程度，提高开发效率，也是对自己学习的一个小结。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由电影票价引发的一些思考]]></title>
    <url>%2F2018%2F12%2F23%2Fthought-about-movie-ticket%2F</url>
    <content type="text"><![CDATA[最近漫威动画大电影《蜘蛛侠：平行宇宙》非常火爆，作为漫威忠实粉丝，当然要去电影院欣赏一番。但是在买电影票过程中，经历了三次选座（前两次并未支付下单），三次的票价都完全不一样，这让我对其定价机制产生了一些思考。 第一次是在昨天晚上，打开支付宝，准备订购电影票，一看有特惠价格¥26.9，还不贵。正要选座下单时，被手机其他消息给干扰，退出了订购界面。 当我再次反应买电影票的时候已经是第二天上午，同样的打开支付宝，同样是显示特惠价格，但是票价为¥35，是的，我又没有买。中午的时候实在觉得无聊，还是决定去看电影，再次打开支付宝，票价显示¥30.5，然后下单支付了。 这个过程我前前后后打开了三次支付宝，这三次经历了什么，支付宝通过我的行为了解了什么，我来说说我的一些揣测。 第一次，选座未支付。支付宝知道了：这B喜欢这部电影，观看的概率很大，但是没有下单，下次他肯定还是会来买，我把价格提高一些，宰你一波。 第二次，点击影片，但未选座。支付宝心里这样想：可能是价格提的太高了，这B接受不了，过会把价格再降低一些，看你买不买。 第三次，选座支付下单。支付宝暗喜：这B终于还是买了，呵呵，机智如我。 当然，以上的都是我的一些揣测，但是不排除这种可能。 在这之前，其实也有看到有人爆料价格歧视的问题。比如有人说当自己再去搜索到同一个目的地的机票时，机票价格就比上一次看到时要贵，因为应用通过你多次访问的数据判断出，你真的要买机票了。 同样的，一些电商公司会通过你的行为数据判断你是不是价格敏感用户，例如同样的商品，如果你第二次访问价格更高时你依然下单了，说明你对价格不敏感（家里有矿），那么之后可能其他的商品也会显示更高的价格给你。 之前也在星球里谈论了关于互联网隐私的话题，如今的人工智能的发展如此迅速，机器可以通过你的行为数据快速分析出你的性格、生活习惯，从而做出相应的反馈。有时候，机器比你更加懂你。 以上的经历告诉我，买东西要省钱，果断一点就对了。看到这里，你可能觉得我屌丝一个，买个电影票都舍不得，还bb这么多。哈哈，我就是这样，自己花钱娱乐精打细算，花钱学习投资自己、请朋友吃饭玩大手大脚，你咬我啊，哈哈！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>思考</tag>
        <tag>电影票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序实现 VR 效果]]></title>
    <url>%2F2018%2F12%2F21%2Fmp-vr%2F</url>
    <content type="text"><![CDATA[小程序中实现VR效果最近的工作中有一个奇葩的需求，就是更根据房间场景图，打开摄像机或者上传图片来适配不同的背景图，类似于VR的效果。 一开始百度搜索，发现小程序根本没有VR的插件，而小程序要实现VR需要使用web-view，也就是使用网页的VR插件，这样的话开发成本会比较大。 在参考了其他的一些小程序后，想到了一种替代的解决办法，也能满足需求，并且有较好的体验。先来看看效果图： 上面的效果是如何实现的呢，其实非常简单，主要使用了小程序的&lt;camera&gt;以及&lt;cover-image&gt;组件。 &lt;camera&gt;组件能够在部分中屏幕显示相机内容，而这个组件又是原生组件，层级最高，因此需要使用&lt;cover-image&gt;，才能做到将camera覆盖。正如所见，图片使用的是一个中间镂空的png图。 关键代码如下： 愿世界不再有需求。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序云开发之初体验]]></title>
    <url>%2F2018%2F12%2F17%2Fmp-cloud-dev%2F</url>
    <content type="text"><![CDATA[小程序云开发是微信最近推出的新的一项能力，它弱化了后端以及运维的概念，开发者无需搭建服务器，使用微信平台提供的api即可完成核心的业务开发。 目前提供三大基础能力支持： 云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码 数据库：既可在小程序前端操作，也能在云函数中读写的 JSON 数据库，免费2G容量 存储：可在小程序前端上传/下载云端文件，在云开发控制台可视化管理，免费5G容量 上手体验打开微信开发者工具，新建工程，选择新建云开发模板，这里appid是必填项。 确认后，工具默认创建好工程如下： 可以看到，工程目录中多了一个cloudfunctions的文件夹，其他的与普通模板目录结构一致，而cloudfunctions文件夹其实就是用来存放云函数的。 云开发控制台点击顶部工具栏中的云开发，会弹出创建的引导，按照提示一步一步创建，这里点击开通。 填写好相应的环境名称信息，可以看到，数据库有2G的空间，另外有5G的存储，可以用来存放一些图片和其他资源，这对于一些小的应用来说是完全够用的。另外，一个小程序可以建立两个环境。 新建好的控制台就是这个样子 云数据库下面通过一个实例来学习小程序的云开发终端云数据库功能。数据库使用的是JSON 数据库，也就是我们所说的nosql，类似于MongoDB，使用键值对应的方式存储数据。 首先进入云开发控制台，选择数据库管理。新建一个集合，也就是一个数据库，输入集合名称。 然后新建一条记录，记录可以手动创建，也可以导入json或者csv数据。id默认自动生成。 那么接下来，就尝试着从小程序端读取数据库中的数据。在index.js中的onLoad函数中加入下面的一段代码 1234567891011// 创建数据库实例const db = wx.cloud.database()// 2. 构造查询语句// collection 方法获取一个集合的引用// 可以使用where 方法传入一个对象，数据库返回集合中字段等于指定值的 JSON 文档。API 也支持高级的查询条件（比如大于、小于、in 等）// get 方法会触发网络请求，往数据库取数据db.collection('user').get(&#123; success(res) &#123; console.log(res) &#125;&#125;) 保存代码，编译运行，观察控制台，发现打印出来的信息中没有数据。 不要着急，这并不是我们的代码写的有问题，而是数据库有权限限制。再次打开控制台，选择数据库权限设置。 可以看到，默认的权限是仅创建者及管理员可读写，这里我们更改为第一个选项，选择所有用户可读，仅创建者可写。再次编译运行，可以看到数据库中的内容成功的被打印出来了。 总结小程序云开发确实是一个不错的功能，大大降低了开发成本，不用再去为服务器、域名、备案等一系列开发流程而发愁，因此如果要开发一些小型的应用，首选云开发。 以上是小程序云开发之初体验，之后的文章会继续深入，持续关注。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>云开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高小程序开发效率]]></title>
    <url>%2F2018%2F12%2F14%2Fmp-more-effectiveness%2F</url>
    <content type="text"><![CDATA[不知道大家开发小程序是用什么工具，如果是微信自带的开发者工具，相信我，看了这篇文章，你会重新做出选择的。 之前一段时间，我也一直使用微信开发者工具进行小程序的开发与调试，但是用过的就会有这种体会： 代码编写区域太小，代码堆叠在一起，难以阅读 自定义能力较弱，只能修改代码字体 编辑器代码提示较少 工具经常出现莫名的bug，时不时黑屏 因此，为了解决这些个问题，果断更换开发工具，这里推荐大家使用号称“宇宙第一IDE”的编辑器——vscode。安装方法不作赘述，主要介绍一下几个vscode插件，在vscode中搜索插件关键字点击安装即可。 minapp支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。 wechat-snippet这个插件主要的功能就是代码辅助，代码片段自动完成，可以作为上个插件的补充。 wxml这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。 有了上面这几款插件，便可以开始高效地撸代码了。至于代码的调试以及效果的查看，当然还是得打开微信开发者工具。将编辑器隐藏，调试工具调到最大，快速找到元素的位置，修改样式，一顿操作猛如虎，Ctrl+S，提交代码。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
        <tag>小程序</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 Flex 布局]]></title>
    <url>%2F2018%2F12%2F02%2Fmp-flex-layout%2F</url>
    <content type="text"><![CDATA[在做前端开发的过程中，页面设计与排版往往成为一大拦路虎。抛开色彩的搭配不说，最让人头疼的无非就是如何让元素在水平或者垂直方向上进行布局排列，并以一定的方式对齐，使得页面显得简洁有序。 在这几周小程序开发工作当中，我也碰到了这样的问题，主要是因为自己CSS功底不扎实，只对几个常用的属性较为熟悉，因此布局起来相当吃力。每次写页面，都要先找一大堆模板，最后堆叠出来的代码我自己都看得恶心。但渐渐的，发现别人的代码中都有使用到flex布局，稍做了解后，确实好用，很快就可以自己编写出好看的页面。 1、flex布局Flex是Flexible Box的缩写，意为”弹性盒子”。传统的布局解决方案是基于盒状模型，依赖 display、position、float这些属性。使用过的人就知道，用起来很不方便，没有响应式，并且对于一些特殊布局很难实现，比如，垂直居中。 之后W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持。下面的例子通过微信小程序实现，网页端同理。 2、布局拆解在对页面进行编码前，通常需要对布局进行拆解，这也是关键的一步，我以下面的图片为例作讲解解。 上面截图是我为某公司制作的官网小程序其中的一部分，布局并不复杂，由外至内进行分析。首先整体布局是一整行，其中有三个子项水平排列，每个子项又可再次进行拆分。 子项同样的由外至内分析，最外层为一个圆形，中间内容可以看作是一个图标和一行文字垂直居中排列，最后的组件拆解图如下。 3、编码实现首先按找布局拆解的思路，先实现三个圆形组件的水平排列。平常我们想到的方式可能是使用浮动或者绝对布局进行定位，但是这样的方式对不同屏幕大小尺寸的设备不友好，容易出现布局错乱。下面使用flex布局看看是如何实现上面效果的。 小程序端页面代码如下，主要是定义几个容器，网页端同理（将view换成div即可）。 12345&lt;view class="circle_line"&gt; &lt;view class="circle"&gt;&lt;/view&gt; &lt;view class="circle"&gt;&lt;/view&gt; &lt;view class="circle"&gt;&lt;/view&gt;&lt;/view&gt; WXSS代码如下，网页端同理。1234567891011121314.circle_line &#123; /* 定义弹性布局，默认水平排列 */ display: flex; /* 设置主轴对齐方式，space-around表示两端对齐，项目间间隔相等 */ justify-content: space-around; /* 在交叉上的对齐方式 */ align-items: center;&#125;.circle &#123; width: 100px; height: 100px; border-radius: 50%; background:linear-gradient(to right, #6372ff 0%, #5ca9fb 100%);&#125; 这时候页面的效果就如下图所示： 首先注意的是flex布局默认排列方式是水平排列。如果对justify-content以及align-item这两个属性可能比较模糊，这里我将第一个属性的所有属性值试一遍，看看效果，另外一个同理，只不过是在交叉轴方向上的对齐方式。 有了上面布局的基础，很快的便可以将圆形内部的图标以及文字进行布局。实现思路就是将图标以及文字放入一个弹性盒子，并将排列方式设置为垂直方向，然后设置居中对齐。wxml代码：123456789101112&lt;view class="circle"&gt; ...&lt;/view&gt;&lt;view class="circle"&gt; &lt;view class="circle_icon"&gt; &lt;image class="circle_icon_image" mode="scaleToFill" src="/images/android.png" /&gt; &lt;/view&gt; &lt;view class="circle_txt"&gt;安卓开发&lt;/view&gt;&lt;/view&gt;&lt;view class="circle"&gt; ...&lt;/view&gt; wxss代码：12345678910111213141516.circle &#123; ... display: flex; flex-direction: column; align-items: center; justify-content: center;&#125;.circle_icon_image &#123; height: 30px; width: 30px;&#125;.circle_txt &#123; color: #fff; text-align: center; font-size: 13px;&#125; 最后保存，就实现下面的效果啦！ 4、总结希望上面过程，不仅仅说是学会了一个什么样的布局，最为关键的还是布局拆解的步骤，因为很多前端的编写都需要有类似的思想。 更多的相关flex布局可以去一些学习网站上做详细了解，祝学习愉快！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>布局</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三我干了啥]]></title>
    <url>%2F2018%2F11%2F20%2Fwhat-did-i-do-in-third-year%2F</url>
    <content type="text"><![CDATA[前些天有一个学弟问我大三是怎么规划的，如图。首先我不敢说是规划，也没有明确的规划，我只是以一个学长的身份，阐述我自己的一些学习经历。 准确来说，我是从大二的暑假才开始接触实际项目，整个暑假都留在学校，和几个小伙伴完成老师的布置的任务，并且每周需要向老师汇报一次工作进度。由于这段时间的项目驱动，自己的专业技能提升的非常快。 大三上学期的课余时间更多的是独立学习，同时完善老师的项目，并且每周参加一次小组的交流会议。另外，开始参加了一些比赛，虽然拿的奖都是省级的，不过至少还可以往简历里面写。在工作面试或者是研究生面试的中，简历中的项目经历以及比赛经历是非常重要，面试官也非常关注这一方面。 大三我还自学了微信小程序，自己开发了几小程序，后面也陆陆续续通过小程序赚了大概几千块钱，至于这钱怎么赚的，以后有时间写一下。现在小程序也开通了流量主，每天有大概十块钱的广告收益，不多，也就吃饭加个鸡腿惹。 至于课程，上课稍微认真听，作业按时完成，考试的时候再好好复习一下，成绩不会很低。大部分的时间我都是自己学习其他东西，大三几乎都在图书馆里面泡着，当然也有偷闲傻玩的时候。但是每次下完课，同学都回寝室，我去图书馆，中午也在图书馆休息，晚上学到闭馆，这是几乎成为大三的日常。不过还好室友都还挺爱学习的，能和我一块奋斗。 总之就是要知道大三没有时间可以玩了，你将来要不就考研，要不就工作，但是上学期复习有点早了（每个人的情况不一样），所以最好就是提升自己的专业技能，多学知识。有些人为了考研，把专业丢了，到研究生阶段还得补回来，这是得不偿失的，所以专业是王道。上学期先把专业知识打牢，这样去考研或者工作，都是不吃亏的。 到大三下学期，要考研的就认真复习，心无旁骛；要找工作的就继续学好自己的专业知识，多刷面试笔试题，为实习做好准备。 话说现在也迷茫的我为什么要写这些东西，科科。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序学习资料及路线分享]]></title>
    <url>%2F2018%2F11%2F08%2Fmp-learning-material%2F</url>
    <content type="text"><![CDATA[最近大家做毕设，好多同学都要做小程序的开发，也有同学问起小程序的开发流程，包括前后端的交互等等，这里就整理一些资料，大家对着资料慢慢学习吧。 小程序端开发小程序端可以理解为Web中的前台，即界面显示，使用一些常用的网页元素以及css，对界面进行布局，使用js进行数据绑定操作。你只需要有基本的html、css、js的基础就能开始学习了，至于如何学习，可以通过视频教程、博客等等的方式，最重要的还是要自己实践，下面是一些相关的资料，自己进行选择性的学习： 微信小程序开发官方文档。文档大概过一遍，大致了解有哪些组件、常用的api就可以了，需要的时候再来查询。 小程序视频教程，提取码: 68yx。这是一套小程序视频教程，虽然教程里的工具以及部分api微信已经更新了，但是基础的东西没有改变，还是有一点价值。另外，也可以去慕课网看一些免费的课程，如果觉得没有太大作用建议去购买付费课程。 小程序源码大全， 提取码: njje。有时候我们写小程序不知道如何布局，这时候参考别人的源码是很有必要的。这里面有120多个小程序的源码，有的包括前后台，可以根据自己的需求进行适当的修改。 小程序后端开发与调试之前在文章中也有提到过，后台的开发语言有很多种选择，可以是php、node.js、也可以是Java，微信对这个没有做出限制，大家可以选择自己最为擅长的开发语言。 后台开发好了，如何在本地对小程序进行调试呢？平时我们使用ssm或者ssh开发好后台后，调试网页的正常运行是在浏览器里输入localhost或者127.0.0.1进行访问服务器。但是小程序的调试是不支持本地域名以及ip地址访问的，因此我们需要将本地的ip映射到外网，这里有个内网穿透工具，具体使用方法大家参考这篇文章：《微信小程序如何搭建本地环境开发》 至于前后台数据如何交互，其实主要使用wx.request这个api，大家多参考官网的文档以及博客。这里放一些博客地址，大家自行参考： 简单的微信小程序与Java后台的连接 小程序学习路线 校徽头像制作小程序前后台源码 校徽头像制作小程序前台教程 校徽头像制作小程序后台教程]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>学习资料</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Flutter 构建 App]]></title>
    <url>%2F2018%2F10%2F29%2Fflutter-build-app%2F</url>
    <content type="text"><![CDATA[Flutter是一套跨平台的移动UI框架，可以快速在iOS、Android以及Fuchsia上构建高质量的原生用户界面。至今，Flutter的版本已经更新到Preview 2.0，这也是正式版发布前的最后一个版本。 Flutter学习之前其实并没有怎么听过Flutter，在参加了Google开发者大会后，经过工程师的介绍，才了解到原来还有这么一个东西。因为自己一直对前端以及移动端的技术比较感兴趣，于是回去便开始着手学习Flutter，尝到了一点甜头后，决定在自己的毕业设计中使用。 学习了大概两个星期的时间，了解了Flutter的基本语法，并把blog、github上的一些demo敲了一遍，然后开始设计毕设界面。毕业设计是做一个电影推荐app，将大概的布局提前在纸上构思了一下，便开始使用Flutter进行构建应用。 整个应用界面的构建大概花了五天时间，当然并不是说是整整五天都在捯饬这玩意，中间也有偷闲。可以看到，界面还不是很完善，比较单一，并没有进行网络交互，所有的数据都是写死的。当然了，这只是一个初步的框架，许多问题都需要在后期进行改进。 那么这样的一个app是如何构建起来的呢，与使用原生Android构建的应用又有那些不同呢？ 开发语言首先从开发语言说起，Flutter官方开发语言为Dart语言，这是一门与Java极为相似的面向对象语言，无论是语法还是特性，只需要有Java或者其他面向对象语言的基础，上手极快，学习成本非常低。下面是Dart的一个官方demo： 12345678910// Define a function.printInteger(int aNumber) &#123; print('The number is $aNumber.'); // Print to console.&#125;// This is where the app starts executing.main() &#123; var number = 42; // Declare and initialize a variable. printInteger(number); // Call a function.&#125; 界面设计在原生的Android应用构架中，界面的设计与逻辑是分离的。界面使用xml进行布局，页面逻辑使用Java进行编写。而在Flutter中，一切都是部件(Widget) ，所有的界面也是完全使用dart代码进行编写，并且支持热加载。即你修改完代码，刷新即可使应用更新。同时，Flutter内置了许多丰富的组件以及动画供开发者使用。 构建方式其实在应用的构建方式上，Flutter和原生还是非常相似的，依然都需要将实体类抽象出来。上面的应用中，其实每一个MovieItem都是一个实体类，通过数据填充的方式，将对应的属性填充到相应的组件中。 每个小的部件都可以独立出来，例如抽屉导航drawer，单独写成一个类，然后每个页面都可以使用。这种抽象的方式在Flutter中非常常见，这也使得Flutter的应用容易扩展，易于后期的修改。 总结Flutter目前来说其实还不稳定，还有很多的坑，这里真香警告。但是对我个人而言，觉得比使用原生的Android开发更加快捷，况且可以使用一套代码，构建出Android端和iOS端的应用，美滋滋？？]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双飞保研经验]]></title>
    <url>%2F2018%2F10%2F25%2Fbaoyan-experience%2F</url>
    <content type="text"><![CDATA[说是说经验，其实就是记录我踩的一些坑，希望后来人能够避免。 前言昌航的保研指标一般在 9 月中旬才下发，在这之前，其实都我不能确定自己能否能够保研，和考研党一样，一直在紧张的复习中，每天的恋练有词，高数刷题一样地经历过。 大概在六月份，学院排了一下前五个学期的排名，我排在第五位。按照以往的指标，软件学院软件工程专业的名额刚好是五个，所以我只要保持，保研应该问题不大。在最后一个学期的考试中，感觉还不错，保研应该有希望，因此在暑假开始便着手了解保研的相关事宜。 说实话，之前一直对保研没什么概念，以为只要拿到保研资格，就可以直接入学了。在经历过失败后，事实证明我错了，明白了自己还不够优秀。 由于我们方向的培养方案不同，大三的暑假需要在南京这边参加实训，因此错过了一些高校的夏令营。直到八月，我才开始着手联系导师。俗话说，近水楼台先得月。由于刚好身处南京，而南京的高校也比较多，因此选择了南京大学和南京航空航天大学作为目标。在给几位导师发送了自荐信和简历之后，便静静的等待消息。有的邮件石沉大海，杳无音讯，有的邮件直接拒绝。最后南大的一位导师表示对我比较感兴趣，我加了他微信进一步的交流。 南京大学推免老师发了一些论文给我，让我自己阅读，并写一篇总结。论文是全英文的，说实话，阅读起来有点吃力。一星期后，我把论文看完，总结也写好了，给导师发过去，导师表示满意，并让我过去见面，商榷本科毕业论文的题目。这一切似乎进行的都很顺利。。。 然而，南大的保研导师是没有决定权的，你依然需要通过其他导师的面试以及上机考试。9 月初，我去参加了面试和机试。面试首先用英文介绍了自己，这个我准备的比较好，也很流利的说出来了。然后是用英文介绍自己的项目以及获得的奖项，这个准备的不是很充分，说的也比较结巴，可能留下了一些不好的印象。最后问了一些软件测试以及数据结构的相关知识，回答的还 ok。晚上进行机试，总共两道题目，一道算法题，一道面向对象，我只做出了一道，测试用例通过 33/43。 最后的的成绩为合格，不是很理想，导师也让我尽早做别的打算。第一次推免以失败告终，而这个时候以及接近九月中旬了，心里着实慌的一批。调整心态后，开始联系其他学校导师。 这里还是要对南京大学的推免做个小结，复试一定要做好充足的准备，南大十分看重英语能力以及实践能力，包括参加的一些比赛获奖，尤其是国奖，这个方面会非常加分，我认为我就差在这个方面，的确还是不够优秀，得不到其他导师的肯定，还得继续努力。 南京航空航天大学推免由于之前把太多的希望都放在了南京大学上面，甚至错过了其他学校的一些预推免，因此这里提醒各位学弟学妹，不要再一棵树上吊死，多做尝试。 之前还与南京航空航天大学的导师有过联系，导师也让我过去面谈。 与导师相谈甚欢，老师问了我自己做的项目，我直接将我做的东西拿给老师看，老师也比较喜欢。然后老师问我研究生的打算，我也将我自己的研究兴趣将给老师听，并表达出自己有继续深造的意愿。总之，经过一番轻松的交流，老师表示可以到他这边来学习，但是不能直博，要读博士的话可以帮我推荐博导。 谢过老师，我心里大概有了底，南航要进去的话应该问题不大。 华中科技大学大学推免华中科技大学的推免与教育部的推免时间一致，需要提交攻读研究生计划书，这个作为笔试成绩，然后进行电话面试，作为面试成绩。计划书更具以往情况，写一个项目的开题报告就行了。电话面试的话也没有很难的问题，问了一下家里面的情况，自己做的项目，研究生阶段的计划等等。最后，提示我面试通过，可以录取。 最后在南航和华科之间还是选择了华科，又是两年。 小结说实话，我的这次保研的经历应该是较为失败的，自己做出的尝试其实不多，抱有侥幸的心理，希望学弟学妹不要学我，一定要多尝试各个学校，面试也要多做准备。趁现在还有时间，多做项目，多参加比赛，丰富自己的经历。另外，也要多向别人请教，不要孤军奋战，共勉吧！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>笔记</tag>
        <tag>研究生</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Google Developer Days 总结]]></title>
    <url>%2F2018%2F09%2F22%2Fgdd-experience%2F</url>
    <content type="text"><![CDATA[为期两天的Google Developer Days结束了，首先非常感谢知识星球球友的赠票，让我有这次与Google近距离接触的机会。不得不说，Google 是真的良心，不仅为每个参与的开发者准备了精美的礼品，大会期间的每个细节都做很好，很为开发者们着想。舒适的听会环境，免费的甜点和饮料，有趣的party以及丰富的产品体验等等。 大会会场大会第一天，早早的来到了世博中心，见到了大会的 logo 异常兴奋。 会场的布置简约大气，两边挂着分会场的分布图，中间是 Google 的 logo。一直十分喜欢 Google 的简白设计，加上一点原色的点缀，简约大方，赏心悦目。 大会演讲简单的参观后，来到主会场，参加大会的 keynote 开幕演讲。演讲的暖场视频放的中国的应用商是如何使用 Google 的技术，提高产品的开发效率以及用户的活跃度。 正式演讲前是一个互动环节，千人同玩猜画小歌，各种灵魂画手上线。 与此同时，猜画小歌也推出好友同玩的新功能，大家可以与自己的微信好友pk。 keynote 的正式演讲由 Google 各个产品的项目经理或者工程师介绍当前项目取得的新进展，以及将来的发展趋势。 Google AI在过去的一年，Google 在人工智能研究以及应用取得了很大进展。Gmail 智能补全，Google Translate 识图翻译，Google Photos 智能分类已经开始应用。 TensorflowTensorFlow 是一个深度学习的框架，可被用于语音识别或图像识别等多项机器学习和深度学习领域。大会介绍了TensorFlow 在 Google 产品中的应用，并且作为一个开源的框架，国内的一些应用厂商以及个人开发者也开始广泛的使用，例如腾讯广告业务、咸鱼、美团有道翻译等产品，都大面积的应用了 Tensorflow。 Android及其工具与语言Android系统在今年更新到了第九个版本，代号 Android Pie。 并且 Android 官方的开发工具 Android Studio 也正式更新到 version3.2，具有更快的编译速度，模拟器的启动速度也大幅度提升。 Kotlin 作为 Android 官方推荐的开发语言，越来越多的人使用Kotlin进行开发，根据问卷，已经有40%的中国开发者使用 Kotlin 进行 Android 应用的开发。 Wear OS功能越来越多，性能越来越强大，总之就是很好。 FlutterFlutter是一款移动应用框架，可以快速的打造美观大方的 App。Flutter 工程师再演讲中宣布发布 Flutter 最后一个预览版，这也是正式版发布前的最后一个版本。其中，新增了许多 iOS 的 Cupertino 风格组件。 ARCoreARCore 帮助开发者打造AR应用，京东平台使用AR技术来方便用户购买商品。例如购买一个冰箱，可以通过 AR 技术，模拟冰箱的大小及其摆放位置，方便用户的选择。 大会午餐大会为开发者提供的午餐，其中有一盒盒饭，一根香蕉，一包原味乐事薯片，以及一瓶印有 Google logo 的矿泉水，营养还算均衡，味道也还不错。 另外，用餐环境十分的舒适，恢弘大气的宴会厅，饭后还可以参观美丽的观景台。 体验区在体验区可以体验到 Google 的各种产品，包括 Move Mirror、猜画小歌、Android、Flutter 应用等等，你不仅仅可以参与体验，还能获得精美的奖品。另外，你也可以与大牛们进行技术交流。可怜我英语口语太渣，只能默默的羡慕那些人对飙英文。 Party晚宴Google为参加大会的开发者举办了晚宴，大家尽情释放。你可以与你的小伙伴参与游戏，可以毫无顾忌的吃上一顿，也可以随着音乐舞动。打了街机，投了篮，看了近景魔术，拿到了纪念T恤，关键还和 dj 小姐姐和了影。 以上就是这次 Google 大会的总结，最大的感悟就是英语很总要，另外就是终生学习。最后，向科技致敬！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>gdd</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可解释推荐系统]]></title>
    <url>%2F2018%2F08%2F26%2Fexplainable-recommendation%2F</url>
    <content type="text"><![CDATA[1. 摘要随着互联网技术和产业的迅速发展，接入互联网的服务器数量和网页数量也呈指数级上升。用户面临着海量的信息，传统的搜索算法只能呈现给用户（user）相同的物品（item）排序结果，无法针对不同用户的兴趣爱好提供相应的服务。为了解决信息过载(Information overload)的问题，人们提出了推荐系统。现如今，推荐系统已广泛地应用到互联网的许多方面。每天，我们阅读着新闻系统推荐的新闻，看着电影网站推荐的电影，听着音乐软件推荐的歌曲，并在电商平台上买下系统推荐的商品。个性化推荐系统的实现，大大方便了用户的使用，提升效率，也改善了用户的体验。 但是，用户面对着系统推荐的物品，心里可能会产生疑惑：为什么向我推荐这些内容。为了使得推荐内容更容易被用户所接受，通常在给用户推荐的同时，加上相应的解释。例如，推荐电影时加上“95%的用户观看后表示喜欢”，推荐商品时加上“根据购买记录推荐下面的商品”等等的解释。相比与传统的推荐系统，可解释系统不仅能够提升系统透明度，还能够提高用户对系统的信任和接受程度 、用户选择体验推荐产品的概率以及用户满意程度等等[^1]。 作为人工智能领域的一个重要分支，可解释推荐系统现已经应用到电子商务、医疗、学术等领域 ，推荐系统的可解释性也是一个重要的研究方向。在《Explainable Recommendation：A Survey and New Perspectives》[^2]中，作者介绍了解释生成的方法模型、可解释系统的评估以及可解释系统的发展方向。下面的内容是对文章的一个总结，并加上自己的一些理解。 2. 解释的形式面对不同的实际应用场景，推荐系统的解释有不同的形式。 2.1 基于用户和物品的解释基于用户和物品的推荐都是一种协同过滤推荐，根据目标用户的行为特征，发现一个兴趣相投、拥有共同经验的群体，然后根据群体的喜好来为目标用户过滤可能感兴趣的内容。基于用户的解释可以表诉为“跟您相似的用户都喜欢该物品”，基于物品的解释可以表诉为“这个物品和您喜欢的其他物品相似”。 2.2 基于内容的解释基于内容推荐解释常见的表现形式是将推荐物品中用户感兴趣的主要特征进行列举。例如，对于基于电影类型，演员，导演等生成电影推荐；基于书籍类型，价格，作者等提供书籍推荐。比如，《哈利·波特》是一本科幻小说；用户爱丽丝很喜欢科幻小说，系统就会直接推荐一本新出版的《哈利·波特》给爱丽丝。 通过以特征作为解释，用户可以直观的理解内容为什么被推荐。 2.3 文本解释文本解释通常是生成一条文本语句作为解释。通过建立模型，分析大量的评论信息，并提取评论当中的特征及其相对应感情色彩，基于模板生成合理的评论句子作为解释。例如，“你也许对【特性】感兴趣”。系统不仅可以提供内容被推荐的解释，同时也能够提高内容不被推荐或者不适合用户的原因，这提高了推荐系统的说服力，可信度。文本解释句子也可以在没有模板的情况下生成，通过使用长期短期记忆（LSTM）生成项目的评论解释，并通过基于学习的大规模用户评论数据，模型可以自动生成合理的评论句子作为解释。 2.4 视觉解释利用视觉图像的直观性，尝试利用产品图像进行可解释的推荐。采用与图像和文本评论信息相结合的神经注意机制来了解图像中每个区域的重要性，并将重要区域作为视觉解释进行突出显示。 2.5 社交解释社交解释通常被应用在社交网络的朋友推荐上。在基于用户的解释中，目标用户可能根本不知道具有“相似兴趣”的用户，通过告诉用户他/她的社交朋友对推荐项目有类似兴趣，那么内容将更容易被接受。UniWalk算法就利用评级数据和社交网络来生成可解释和准确的产品推荐。 2.6 混合解释在许多实际系统中，将多种类型的解释整合为对用户的混合解释，以使用户可以从多个角度理解推荐。系统利用多种推荐算法来构建混合推荐系统，因此，对混合推荐输出的解释一致是十分重要的。 3. 可解释推荐系统模型目前大多数的可解释推荐方法是基于模型的方法，即推荐由矩阵/张量因子分解，分解机，主题建模和深度推荐模型等模型提供，同时，模型的推荐结果可以作为解释。 3.1 矩阵分解模型许多可解释的推荐模型是基于矩阵分解的方法提出的，最为典型的代表有隐因子模型(LFM)和显因子模型(EFM)。 3.1.1 隐因子模型(LFM)隐因子模型抽象出隐因子空间，其中隐因子可以理解为一个用户喜欢一个电影的隐形原因，比如电影里面有他喜欢的romantic和action元素，还有他喜欢的某个演员或者导演编剧。如果另外一个电影有类似的元素跟演员，那么他很有可能会也喜欢这部电影。LFM的核心思路就是通过评分矩阵，求出用户的向量和电影的向量[^3]。隐因子模型的特点是分类过程中，不需要关心分类的角度，结果都是基于用户打分自动聚类的，分类的粒度通过设置LFM的最终分类数来控制。 但是，隐因子模型存在着一些不足： 单一的打分不能反映用户对物品各项特征的偏好，没有利用到用户评论。 类别是抽象出来的，没有明确的含义，所以向用户推荐物品时，很难给出推荐解释。 3.1.2 显因子模型为了避免隐因子的一些问题，研究者提出了显因子模型，其基本思想是推荐在用户关心的功能上表现良好的产品[^4]。 通过对用户评论进行phrase-level（短语级）的情感分析，显式地抽取物品的特征和用户的意见。 例如下图，从用户评论中抽取物品的特性：screen、earphone。然后，抽取用户对这些特征的意见：perfect、good。如果这些表示意见是积极的情感，则用1表示；反之则用-1表示。所以在下面的例子中，情感短语表示为（screen, perfect, 1）, （earphone, good, 1）这样的三元组，这一条条短语就组成了情感词典。 通过构建用户打分矩阵、用户-特征关注矩阵以及物品-特征质量矩阵，估计损失值，最后生成Top-K推荐，并可根据特征向用户解释推荐理由。 显因子模型主要的优点有： 充分利用用户评论，提高算法的精准度。 直观地解释推荐理由，从而帮助用户更快决定是否购买。特别是建议用户不要购买某些物品，有助于提高用户对系统的信任度。 另外，也有研究者将此模型拓展到张量均匀化，构建用户-项目-特征立方体，通过成对学习精选排序以确定用户对特征和项目的偏好，这有助于缓解矩阵稀疏性的问题。 3.1.3 其他有研究者提出了情感效用逻辑模型（SULM），通过从评论中提取用户对物品特征的情感，并将这些特征和情感被整合到矩阵分解模型中，适应未知的情绪和评级，最终用于生成建议。所提出的方法不仅向用户提供推荐的项目，而且还提供项目的推荐特征，并且这些特征用作推荐的解释。 另外研究人员还研究了基于模型的用户和/或基于项目的解释方法，这些方法可以仅根据用户项目评级矩阵提供可解释的建议。也有科学家提出提出可解释的受限Boltzmann机器用于协同过滤和推荐，该方法可提供基于用户的邻域样式解释。 3.2 主题模型主题模型是对文字隐含主题进行建模的方法。例如，判断两篇文档是否相关往往不只决定于字面上的词语重复，还取决于文字背后的语义关联。对语义关联的挖掘，可以让我们的搜索更加智能化。而主题模型则是用于解决这个方法的非常经典的模型。 它克服了传统信息检索中文档相似度计算方法的缺点，并且能够在海量互联网数据中自动寻找出文字间的语义主题。 研究者们首先提出隐藏因子和主题（HFT）模型，通过将项目（或用户）潜在向量的每个维度相关联，将潜在因子模型和潜在Dirichlet分配（LDA）联系起来，提高评级预测的准确性。随后，有研究者提出提出了FLAME模型（Factorized Latent Aspect ModEl），它结合了协同过滤和基于方面的意见挖掘的优点。从过去的评论中了解用户对不同方面的个性化偏好，并通过集体智慧预测用户对新项目的评估。 3.3 深度学习模型深度学习和表征学习在推荐研究界引起了很多关注，并且它们被广泛应用于可解释的推荐上。到目前为止，相关的可解释推荐模型涵盖了广泛的深度学习技术，包括卷积神经网络（CNN），循环神经网络RNN / 长短期记忆网络（LSTM），注意力机制，记忆网络等，它们被应用于关于可解释性的各种推荐任务，例如top-n推荐， 顺序推荐等。 有研究者使用卷积神经网络（CNN），对具有双重局部和全局关注的文本评论来模拟用户偏好和物品属性，突出显示评论中的相关单词作为解释，以帮助用户理解建议。另外也有研究者引入了注意机制来探索评论的有用性，并提出了一种神经注意回归模型，其中包含了复习水平的解释推荐。最近，基于自然语言生成的可解释建议已经应用于商业电子商务系统。例如，淘宝的推荐系统根据数据对序列的自然语言生成推荐项目解释。 3.4 知识图谱知识图谱最初由谷歌公司于2012年5月16日宣布推出，旨在提升搜索引擎返回的答案质量和用户查询的效率 。有知识图谱作为辅助，搜索引擎能够洞察用户查询背后的语义信息，返回更为精准、结构化的信息，更大可能地满足用户的查询需求[^5]。 在各种辅助信息中，知识图谱作为一种新兴类型的辅助信息近几年逐渐引起了研究人员的关注。知识图谱（knowledge graph）是一种语义网络，其结点（node）代表实体（entity）或者概念（concept），边（edge）代表实体/概念之间的各种语义关系（relation）。[^6]一个知识图谱由若干个三元组（h、r、t）组成，其中h和t代表一条关系的头结点和尾节点，r代表关系。例如下图所示的关系，表达了斯蒂文·斯皮尔伯格导演了头号玩家电影，其中h=斯蒂文·斯皮尔伯格、t=头号玩家、r=导演。 通过组合若干个语义关系，可以生成知识图谱。知识图谱中包含了实体之间丰富的语义关联，可为推荐系统提供了潜在的辅助信息来源。和其他的推荐模型相比，知识图谱的引入可以让推荐系统有如下特性： 精确性。知识图谱为物品引入了更多的语义关系，可以深层次地发现用户兴趣。 多样性。知识图谱提供了不同的关系连接种类，有利于推荐结果的发散。 可解释性 。知识图谱可以连接用户的历史记录和推荐结果，从而提高用户对推荐结果的满意度和接受度，增强用户对推荐系统的信任。 但是，知识基于路径的知识图谱推荐方法存在一定的局限性，研究者提出了Ripple Network。这是一个将知识图纳入推荐系统的端到端框架，类似于在水面上传播的实际波纹，通过自动迭代，沿知识图中的链接扩展用户的潜在兴趣，并可以在知识图上找到推荐项路径来提供解释。 3.5 数据挖掘数据挖掘方法对于推荐研究很重要，数据挖掘方法通常具有可解释推荐的特别优势，因为它们可以生成非常直接的解释，并且这些解释易于用户理解。一个典型的例子就是“沃尔玛啤酒和尿布”的故事。 现如今，很多的互联网平台，包括电商、视频、打车等平台在内，都会使用数据挖掘的方式对用户进行商品的推荐，用户每天浏览消费，产生海量的数据供平台分析。平台通过分析数据，可以直观的告知用户当前的流行趋势、地区特色等等，并以此为解释将物品推荐给用户。 作者还在文中提到Youtube视频推荐系统，推荐系统是通过网站上用户监视活动的会话，为每个用户设置视频的种子集，其中包括用历史、收藏、喜欢、评级等等视频，将这些种子视频的相关视频作为推荐候选项目，并将关联规则作为解释。虽然现在（2018年）Youtube的视频推荐是不提供推荐解释，但是推荐到内容却是如此的精准，这是因为Google在2016年开始采用了深度学习算法，包括Google Assistant、Google Map、Google Photos等等谷歌产品。尤其是在今年2018的Google I/O大会上，Google的AI技惊四座，将AI又推向新的热潮。 4. 可解释推荐系统的评估中国有句谚语：鱼和熊掌不可兼得，这似乎一直是一个历史难题。人们在想要得到某一些东西的时候，往往需要失去另一些东西。在算法领域，为了设计出一个时间效率高的算法，通常会舍弃一些空间，这是所谓的空间换时间。同样的，在推荐领域，为了使得推荐性能更好，不得不在可解释性上做出让步。因此，可解释的推荐算法的评估主要在评级预测或top-n推荐方面，以及评估说服性和有效性等方面的解释性能。下面就推荐性能以及推荐解释性的评估方法做出总结。 4.1 推荐性能评估推荐性能的评估方法分为离线评估和在线评估。在离线方法中，通常可以使用平均绝对误差（MAE）和均方根误差（RMSE）来评估评级预测的性能。对于top-n推荐，可以使用许多排名度量进行评估。 最常用的度量可以是精确度，召回率，F1度量值，归一化折扣累积增益量（NDCG）等。在在线方法中，通过点击率（CTR），转换率（CR）以及其他与业务相关的衡量指标进行评估。在线评估通常被商业公司使用，可以通过大量用户的访问进行实验。 4.2 解释性能评估解释性能评估的方法中也包含在线评估和离线评估，另外还包括用户研究和案例研究评估。通常，在线评估更容易实施，而在线评估和用户研究取决于实际系统中数据和用户的可用性。 4.2.1 离线评估离线评估通常有两种评估推荐解释的方法。一种是忽略解释质量，评估可解释推荐模型可以解释的推荐项目的百分比；第二种方法是准确评估解释的质量。但是，为了更全面地评估建议解释，需要更多的离线评估措施和协议。 4.2.2 在线评估评估解释建议的另一种方法是通过在线实验，也是基于转换率（CR）和点击率（CTR）等在线测量，类似于推荐性能的在线评估。可能有几种不同的观点需要考虑在线评估解释，包括说服力，有效性，效率和解释的满意度。 4.2.3 基于用户研究的模拟在线评估在线评估需要一个拥有大量用户的已部署系统，这通常需要广泛的协作或与商业公司合作。一种较为简单的方式是通过基于志愿者或付费实验科目的用户研究，模拟在线评估。志愿者或有偿受试者可以直接由研究人员雇用，也可以基于各种在线众包平台聘用。 4.2.4 案例研究定性评估作为定性分析的案例研究也经常用于可解释的推荐系统研究。提供案例研究有助于理解可解释推荐模型背后解释的有效性，并且有助于读者理解提议的方法何时起作用以及何时不起作用。研究者提供了解释顺序的案例研究，作者发现许多顺序建议都可以根据用户的“一对多”或“一对一”行为模式进行解释，这些解释可以帮助用户清楚地理解为什么推荐一个项目，以及推荐的方式。 5. 可解释推荐系统的应用可解释推荐的研究和应用跨越了许多不同的场景，例如可解释的电子商务推荐，可解释的社交推荐，可解释的多媒体推荐等，甚至在医疗、学术等领域 ，也已经开始应用。 可解释推荐系统在电子商务产品的推荐中被广泛采用，平台通过商品的推荐可以提供个性化服务，提高用户信任度和粘性。当然，还可以增加营收。 例如，亚马逊每年35%的销售额都来源于它的推荐。在社交领域中，好友的推荐、新闻推送推荐以及以及社交环境中的博客，新闻，音乐，旅行计划，网页，图像，标签等的推荐。社交关系不经能够提高推荐性能，还可以提高推荐的解释能力。可解释性推荐对许多其他应用场景也很重要，例如学术推荐，引用推荐，医疗保健推荐等。虽然关于这些主题的直接可解释推荐工作仍然有限，但研究人员已开始考虑可解释性问题在这些系统中。 6. 新的研究方向长期以来，推荐系统主要集中在开发广泛的模型，以尽可能有效地找到最相关的结果。然而，推荐模型的可解释性却被忽视了。缺乏可解释性主要存在于两个方面： 推荐系统的输出（即推荐结果）难以向系统用户解释。 推荐模型的机制（即推荐算法）对系统设计师来说难以解释。 现如今，随着科技的不断发展，不断有新的研究成果出现，我们可以通过使用深度学习、知识增强、异构信息模型、自然语言生成等技术，来使得推荐模型生成解释。作为人工智能领域的一个研究分支，越来越多的人加入到其中的研究。期望知识图谱技术，深度学习，自然语言生成，动态建模，模型聚合和会话系统技术在可解释的推荐方面取得更多成就，可解释的推荐系统的目标也将超越说服力，以进一步使系统用户/设计者在许多其他方面受益。 [^1]: 微软亚洲研究院. 可解释推荐系统：身怀绝技，一招击中用户心理. https://zhuanlan.zhihu.com/p/29374802.[^2]: Yongfeng Zhang and Xu Chen. Explainable Recommendation：A Survey and New Perspectives. arXiv Preprint 2018. arXiv:1804.11192.[^3]: CSDN. LFM (Latent Factor Model) 隐因子模型 + SVD (singular value decomposition) 奇异值分解. https://blog.csdn.net/asd136912/article/details/78290679.[^4]: Zhang Y, Lai G, Zhang M, et al. Explicit factor models for explainable recommendation based on phrase-level sentiment analysis[M]. ACM, 2014.[^5]: Wikipedia. Knowledge Graph. https://en.wikipedia.org/wiki/Knowledge_Graph.[^6]: 微软亚洲研究院. 推荐算法不够精准？让知识图谱来解决 https://zhuanlan.zhihu.com/p/37943501.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 组件介绍]]></title>
    <url>%2F2018%2F07%2F16%2Fflutter-component-intro%2F</url>
    <content type="text"><![CDATA[Flutter 是 Google 开源的跨平台移动开发框架，它能够使开发者快速的构建出美观的、高性能的移动应用程序。 Flutter 的核心理念：一切皆为 Widget。手机应用里的所有东西都是 Widget，开发者通过可组合的空间集合、丰富的动画库实现了富有感染力应用界面设计。 Flutter 的 UI 库里面有两套小部件 —— Material Design（适用于 Android ）和 Cupertino（适用于 iOS ）今天，通过 Flutter Gallery，也就是一个 demo 来给大家展示 Flutter 的组件。 首先是 Material Design 风格的的组件 底部导航栏（Bottom navigation）底部导航栏分为固定以及渐变导航，由图标以及文字组成 按钮（Buttons）按钮有图标按钮，扁平按钮，浮动按钮等等 卡片（Card）卡片包括了图片、标题以及操作按钮 芯片（chips）这个有点类似于一个 badge，可以当作标签使用 日期和时间选择器（Date and time pickers） 对话框（Dialog） 侧边导航 （Navigation drawer） 可展开列表 （Expand/collapse list control） 浮动按钮 （Floating Action Bar） 网格布局 （Grid list） 图标 （Icon） 进度指示 （Progress indictors）分为圆形和条状的进度指示 可滚动的标签页 （Scrollable tabs） 滑动条 （Sliders）分为连续以及不连续的滑动条 下面是 iOS 风格的组件 按钮（Buttons） 对话框 （Dialog） 滑动条 （Sliders） 切换按钮 （Switches） 导航 （Navigation） 以上就是 Flutter 中的所有的组件，需要用时可以参考。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序添加广告并获取收益]]></title>
    <url>%2F2018%2F07%2F15%2Fmp-add-banner-ad%2F</url>
    <content type="text"><![CDATA[小程序广告组件最近全面开放，门槛十分低，只需要累计独立访客（UV）不低于 1000，并且没有严重违规记录。下面教大家如何在小程序中添加广告。 申请成为流量主首先进入小程序后台，点击流量主，点击开通。 同意协议并点击下一步。 填写个人的相关信息，包括身份证、收款账户等等。 最后提交，系统会进行审核，审核时间说是大约一周，但是我上午提交的申请，下午就通过了，效率还是挺高的。 在小程序中嵌入广告审核通过后，后台界面会做出相应的变化，我们根据提示来创建广告位。点击立即创建，填写广告的名称，点击确定。 创建好后就会显示在管理页面中，你也可以选择创建多个广告，但是有些广告的曝光率会比较低。 点击获取代码，将广告位的代码复制下来，并放在小程序的相应位置 然后打开微信开发者工具，打开你的小程序工程，在相应的位置粘贴广告代码，保存编译，广告就显示在小程序中了。至于广告的位置，建议放在底部最为合适，如果放在中间，用户的体验会非常的不好。 最后上传代码，并提交给后台进行审核，审核通过后，你的小程序便可以重新发布，小程序下面就出现了广告 banner。 收益统计在后台可以对小程序广告的点击次数、曝光量以及收益进行统计，平均点击一次的收益为 0.5 元，所以如果你的小程序的用户数量足够庞大，完全就能够实现财务自由了。 小程序现在学习门槛极低，变现门槛也很低，有兴趣的完全可以学习一下，尤其是我们大学生，如果能够变现，多多少少可以减轻一些生活上负担。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「校徽头像小程序」开发教程]]></title>
    <url>%2F2018%2F07%2F09%2Flogo2avatar-dev-tutorial%2F</url>
    <content type="text"><![CDATA[之前公众号推过一个头像制作的工具类小程序，通过图片叠加的技术，实现头像与校徽图片的叠加，并生成新的头像图片，今天首先教大家制作小程序前台界面。 1、创建工程打开微信开发者工具，新建一个工程，输入自己的AppID，勾选快速启动模板，点击确定。 2、编写页面元素代码页面设计的非常的简单，一个卡片式的方块存放图片，加上两个简单按钮。选择index文件下的index.wxml，删除原有代码，写入新的页面代码如下。 123456789101112&lt;!--index.wxml--&gt;&lt;view class="container"&gt; &lt;view class="userinfo card"&gt; &lt;image bindtap="bindViewTap" class="userinfo-avatar" src="&#123;&#123;avatarUrl&#125;&#125;" mode="cover"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='operation'&gt; &lt;button bindtap='openAlbum' type='default' size='&#123;&#123;buttonSize&#125;&#125;'&gt;选择相册图片&lt;/button&gt; &lt;button bindtap='exportPic' class='export' size='&#123;&#123;buttonSize&#125;&#125;' type='primary'&gt;一键导出头像&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; 3、编写css代码如果只写上面的代码，页面会非常的难看，我们需要编写一些css代码，将页面的整体布局调整为我们能够接受的样子。首先修改index.wxss，设置图片的长宽，并修改&lt;view&gt;标签的样式，为其添加阴影，最后设置按钮的长度以及间距。代码如下：1234567891011121314151617181920212223242526272829303132333435363738/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 450rpx; height: 450rpx; margin: 20rpx;&#125;.card &#123; position: relative; margin: .5rem 0 1rem 0; background-color: #fff; -webkit-transition: -webkit-box-shadow .25s; transition: -webkit-box-shadow .25s; transition: box-shadow .25s; transition: box-shadow .25s, -webkit-box-shadow .25s; border-radius: 2px; -webkit-box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.2); box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.2);&#125;.userinfo-nickname &#123; color: #aaa;&#125;.operation &#123; margin-top: 50rpx;&#125;.export &#123; margin-top: 30rpx;&#125; 然后，修改整体元素的布局，修改app.wxss中的代码，为container类中的元素添加外边距，代码如下： 1234/**app.wxss**/.container &#123; margin: 50rpx;&#125; 4、编写js代码js代码主要是图片的上传与下载以及页面元素数据的绑定。首先是对页面绑定的数据进行填充，这里有两个数据，一个是图片的url，另一个是按钮的大小。代码如下： 1234data: &#123; avatarUrl: "https://zouxiaoming.xyz:8443/images/152799490334logo.png", buttonSize: 'default' &#125;, 然后通过自定义函数对两个按钮的点击事件进行绑定，首先是点击选择相册图片按钮，需要打开手机相册，选择照片后再对照片进行上传，服务器接收到了图片请求，会将处理好的新的图片的url返回。如果成功，会执行success的回调函数，因此我们在success的函数中将新的图片url进行数据绑定，并提示上传成功。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940openAlbum: function () &#123; var that = this; // 打开手机相册 wx.chooseImage(&#123; success: function (res) &#123; var tempFilePaths = res.tempFilePaths; // 上传图片 wx.uploadFile(&#123; url: 'https://zouxiaoming.xyz:8443/avatar_change/saveHeaderPic', filePath: tempFilePaths[0], name: 'file', // 上传成功，执行success函数 success: function (res) &#123; var data = JSON.parse(res.data); var avatar_url = 'https://zouxiaoming.xyz:8443/avatar_change/images/' + data.url; that.setData(&#123; avatarUrl: avatar_url &#125;); // 弹出toast提示 wx.showToast(&#123; title: '图片上传成功', icon: 'succes', duration: 2000, mask: true &#125;); &#125;, // 如果失败，执行fail函数 fail: function () &#123; wx.showToast(&#123; title: '图片上传失败', icon: 'none', duration: 2000, mask: true &#125;); &#125; &#125;) &#125;, &#125;) &#125; 保存代码，工具自动编译运行。 选择一张图片进行上传测试，后台我已经搭好了，大家如果需要测试记得上传地址就和代码里的一致就行。 最后就是保存图片了，首先为一键导出头像按钮定义一个点击事件，然后再事件中下载图片。代码如下：1234567891011121314151617181920212223242526272829303132// 导出图片exportPic: function () &#123; var that = this; // 下载图片 wx.downloadFile(&#123; url: this.data.avatarUrl, success: function (res) &#123; console.log(res); // 保存图片至相册 wx.saveImageToPhotosAlbum(&#123; filePath: res.tempFilePath, success: function (res) &#123; console.log('success'); wx.showToast(&#123; title: '保存成功', icon: 'succes', duration: 2000, mask: true &#125;); &#125; &#125;) &#125;, fail: function () &#123; wx.showToast(&#123; title: '图片下载失败', icon: 'none', duration: 2000, mask: true &#125;); &#125; &#125;) &#125; 点击导出按钮，图片就导出到本地了，如果在手机上测试则会导出到手机相册。 最后再去更换自己的头像吧！ 总结其实这个小程序实现起来并不是很难，只有一些简单的事件绑定。只需要了解一些小程序基本的api，就能够开发出来，大家有时间的可以去试试，后台我已经搭好了，大家可以直接使用。 有疑问的记得留言哦，我会尽力解答的，本次教程的源码在公众号后台回复校徽头像小程序源码可以获得下载连接。看完了别忘了点个赞哦！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>开发教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度云破解]]></title>
    <url>%2F2018%2F06%2F22%2Fbaidu-cloud-pojie%2F</url>
    <content type="text"><![CDATA[百度网盘破解不限速，手机和电脑端的都有，再也不用看百度的脸色了 百度网盘现在是市面上较为流行的网盘软件，经常会在上面分享或者保存一些文件。之前注册的用户免费赠送 2T 的内存空间，现在只有做任务才能领取。 然而这都不重要，百度网盘给我们带来便利的同时，有时候也是让我们抓狂。是的，就是它那缓慢的下载速度。正常的时候下载速度有几百 KB，这个还能够接受。但软件往往抽风，对网络做出网速限制，速度只有几 KB 或者几十 KB。这对于用户来说是无法忍受的。 想一想，你找到了一部你想看的电影，大概 1G 左右。但是就是那几十 KB 的网速，需要下载两三个小时，看电影的心情早就没了。 因此，给大家推荐下面两个软件，一个是 Android 端的 App，另外一个是电脑端的应用程序。可以分别在电脑以及手机端使用，下载速度不会受限制。经过测试，20M 的宽带下载速度最快可达到 2M/s 左右。 Village这是一个 Android 端的 App，除了不能在线看视频外，基本还原了百度网盘 app 的所有操作。另外，还支持多帐号登录，自定义分享密码，批量重命名等等。关键下载网速不受限制，支持自定义多线程下载，移动网络下载最快可以达到 10M/s。 另外还有一个超级强大的资源搜索功能，能够搜索到全网的分享资源。比如我想听听 Taylor 的歌或者想看最近的电影，直接搜索，如果有结果，可以保存到自己网盘后进行下载。 公众号后台回复 Village 下载 PanDownload这是一个 Windows 端的应用程序，同样也是破解网速的限制。无需安装，解压即用。第一次进去需要登陆，剩下的操作就和电脑端的差不多了，除了界面土了点。基本功能都有，另外还可以设置下载完关机。 公众号后台回复 PanDownload 进行下载 如果用得心里过意不去，还是冲个会员支持一下正版吧]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序学习感悟]]></title>
    <url>%2F2018%2F06%2F21%2Fthoughts-about-mp-learning%2F</url>
    <content type="text"><![CDATA[2017年1月，微信正式发布小程序，小程序逐渐进入公众的视野。不温不火的几个月，随着小程序的生态不断的扩大完善，用户数量呈爆炸式的增长，越来越多的人投入小程序的怀抱。 当时的我，正值大二，小菜鸟一枚。不知道什么是前端，什么是后端，更别提服务器了，所掌握的不过仅仅是常规的课堂知识。没有做过实际的项目，只会用Java写一个Hello World。心里其实是想去学一些东西，但却往往是没有方向，不知道从何下手。 于是乎我便自己摸索，大二的寒假，我抽时间将数据库方面的知识提前学习了一下，并在大二下学期的课程设计中运用，这应该算是我第一次实际的项目经历了。大二下学期是我学东西学得最多的一个学期，除了上课或者带训，其他时间我几乎都在学习专业知识。HTML，JavaScript，CSS，Android，JSP等等。 很多人会有这样的感觉，学的时候一脸懵逼，不知道学的东西能用来干嘛，不知道如何应用。但是其实知识这种东西是需要慢慢积累的，等到积累到一定的程度，便融汇贯通了。 微信的每次更新我都在关注，直到微信小程序的上线，微信的生态及其宏大的战略观，微信的每一步棋下的是如此之妙。在我打好了一定基础之后，大二的暑假我便开始了小程序的学习。买了本小程序的教程书，结合微信官方给的文档进行学习。发现小程序上手真的很快。你只需要掌握一些基本的前台网页相关的知识，就可以制作出一个简单的小程序。当然了，如果要进行前后台的交互，还需要服务器以及数据库相关知识。 我的第一个小程序是一个天气查询的小程序，使用的是百度api的天气数据接口（现在接口应该失效了）。说实话，作用不是很大，用户数也是寥寥无几。但是对我来说确实是一个小小的锻炼，理解了小程序的工作原理及其运行机制。之后，我又制作了一个音乐播放的小程序，遗憾的是，在用户数快到达5w的时候，微信停止了所有个体单位开发的音乐类小程序，可能是因为版权原因，也无法再打开使用。 但是在经过两个小程序的实操后，对小程序的开发流程已经是了如指掌。这学期在不到两天的时间里面，开发了体测计算器以及校徽头像的小程序，用户数现在也较为可观。 就学习小程序开发利弊来说，小程序的迭代更新速度比较快，可能你的小程序昨天还可以用，第二天就崩了。因为微信这边要从用户体验的角度考虑，必须不定期的对小程序的API进行更新，因此代码也得进行相应的改变。但总的来说，小程序还是非常值得大家去学习，不仅能锻炼到自己的编程能力，如果小程序的用户数大的话，也是对自己的一种鼓励，还可以获得一定的广告收入。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F06%2F16%2Fscience-fuck-net%2F</url>
    <content type="text"><![CDATA[免费科学上网，超级简单 众所周知，我们国家为了网络安全以及营造一个良好的网络环境，对某些网络做了一些安全限制。很多人不理解，但就中国现如今的国情，这确实是一个正确的举措。 对于我们这个专业来说，如果遇到问题无法在国内的网站上找到解决方案，这时候需要去国外的网站上进行一些资料的查找，例如 Google 学术、维基百科、Stack Overflow 等等。甚至我们写论文的时候，也会需要去参考一些外文资料。因此，科学上网成为一种生存的本领。 另外，还可以使用一些国外比较优秀的应用，例如使用 Youtube 用来学学英语、Google 套件方便自己的工作，Instagram 或者 Twitter 来填补一下在外网社交方面的空缺。 那今天就教教大家如何在 Android 手机以及 Windows 系统中进行科学上网。 snap vpn这是一个手机端的vpn应用，傻瓜式操作，一键连接。有多条免费的线路可以选择，不限流量，不限时间，但用到一定流量会进行限速。YouTube 视频最快可以达到 5M/s，手机上刷刷 Instagram、Twitter 或者 Youtube 完全不成问题，能够解决大部分人手机端的需求。公众号后台回复 Snap 可以获得下载链接。 Shadowsocks一个电脑端的服务器代理，很多人都是通过买外网服务器，然后搭建 ss 或者 ssr。这里教大家使用免费的服务器。首先下载 Shadowsocks 的客户端，客户端不需要安装，下载好就可以使用。打开客户端，屏幕右下方任务栏出现一个灰色的小飞机图标。 然后在浏览器输入网址：https://get.ss8.fun/ ，打开下面的网页。 任意点击一张图片，会弹出服务器的二维码。 右击小飞机图标，选择服务器 —&gt; 扫描屏幕上的二维码。 扫描完后，弹出弹框，直接点击确定。 最后右击小飞机，启用系统代理，这时候小飞机图标变成亮白。然后在浏览器地址栏中输入一下 Google 的地址：https://www.google.com/ ，发现成功打开 Google 的首页，也可以进行搜索。 Youtube 也能上去，速度还不错，看高清的也不卡。 后台回复小飞机下载客户端。 最后祝大家上网愉快]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次维权经历]]></title>
    <url>%2F2018%2F06%2F12%2Fa-defend-note%2F</url>
    <content type="text"><![CDATA[某客来牛排店出售过期啤酒，下面是维权过程 前不久，和两个朋友一起去学校附近山姆会员店的某客来牛排店吃牛排。点了三份牛排，三瓶百威啤酒。打开啤酒时，啤酒的气冒的有点足，但是喝之前并没有摇晃。喝了两口，觉得有点不太对劲，便看了看瓶子标签的生产日期。一看傻眼了，生产日期2017年7月，保质期6个月，足足过期5个月。 我和朋友们说，咱们这顿饭应该可以免单了。首先拿相机拍下了啤酒瓶上的标签作为证据，然后上网查了一下相关法律条款，商家需要十倍赔偿。一瓶百威十块钱，我们点了三瓶，因此按照法律规定，商家需要赔付我们300元的赔偿金。 很巧的是，有位朋友的姐姐是一名律师，还特地打电话咨询了一下，同样给出的答复是要求十倍的赔偿，并且可以拨打消费者协会电话12315进行举报。之后，经理过来和协商，我们便顺理成章的免费吃了一次牛排。 大家出去吃东西或者买东西时一定要查看生产日期。如果出现这种情况，也要学会维护自己的合法权益。不要让别人认为学生是好欺负的，惹谁也不要惹知识分子。 突然觉得，懂点法律知识真的很重要]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>维权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 reveal.js 制作网页 ppt]]></title>
    <url>%2F2018%2F06%2F06%2Frevealjs-make-ppt%2F</url>
    <content type="text"><![CDATA[今天教大家使用reveal.js，制作一个简洁优雅的网页ppt。在这之前，你需要一些基本的HTML以及CSS的技能基础。 1、准备工作 下载插件，插件下载地址：https://github.com/hakimel/reveal.js 解压文件，将相关的js以及css引入html界面 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;reveal.js&lt;/title&gt; &lt;!-- reveal基本的css --&gt; &lt;link rel="stylesheet" href="css/reveal.css"&gt; &lt;!-- 引入黑色主题 --&gt; &lt;link rel="stylesheet" href="css/theme/black.css"&gt; &lt;!-- 用于显示代码高亮 --&gt; &lt;link rel="stylesheet" href="lib/css/zenburn.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- reveal基本的js，里面集成了一些转场动画 --&gt; &lt;script src="js/reveal.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2、制作第一页ppt在html页面中创建两个div块级元素，注意，class类名必须分别为reveal和slides。在第二层div中创建section标签，每一个&lt;section&gt;块都生成一张单独ppt。最后，在js代码中对页面进行初始化。 123456789101112131415161718192021&lt;!-- 这里省略引入css代码，记得加上 --&gt;&lt;div class="reveal"&gt; &lt;!-- 所有的幻灯片都放在一个类为slides的div中 --&gt; &lt;div class="slides"&gt; &lt;!-- 每一个&lt;section&gt;块都生成一张单独ppt --&gt; &lt;section&gt; &lt;!-- ppt标题 --&gt; &lt;h1&gt;How to use jQuery&lt;/h1&gt; &lt;!-- ppt正文 --&gt; &lt;p&gt; &lt;small&gt;Presented by &lt;a href=""&gt;MayanDev&lt;/a&gt;&lt;/small&gt; &lt;/p&gt; &lt;/section&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 这里省略引入js代码，记得加上 --&gt;&lt;script type="text/javascript"&gt; // 初始化页面 Reveal.initialize();&lt;/script&gt; 保存，用浏览器打开，显示效果如下图。（F全屏，ESC退出） 3、fragment类这里再第一页的基础上再添加一个section，其中fragment类表示分条显示，当键盘按下?键时触发。section中还可以包含section，放映的方式为向下放映。通过data-background属性可以设置幻灯片的背景颜色或者图片，甚至可以使用视频当作背景。12345678910111213141516171819&lt;!-- 这里省略第一页及其他内容 --&gt;&lt;!-- 第二页 --&gt;&lt;section&gt; &lt;!-- section中还可以包含section，放映的方式为向下放映 --&gt; &lt;section&gt; &lt;h2&gt;Hello There&lt;/h2&gt; &lt;!-- fragment类表示分条显示，当键盘按下?键时触发 --&gt; &lt;p class="fragment"&gt;Today, we are gonna talk about the jQuery.&lt;/p&gt; &lt;!-- 添加一个图片链接 --&gt; &lt;a class="fragment" href="http://jquery.com/download/"&gt;&lt;img width="240" height="180" data-src="images/jquery_logo.gif" alt="jquery_logo"&gt;&lt;/a&gt; &lt;/section&gt; &lt;!-- 通过data-background熟悉可以设置幻灯片的背景颜色或者图片，甚至可以使用视频当作背景 --&gt; &lt;section data-background="#dddddd"&gt; &lt;h2&gt;But then, Believe me...&lt;/h2&gt; &lt;p class="fragment"&gt;You need some HTML,CSS and JavaScript skills to be able to use jQuery effectively. &lt;/section&gt;&lt;/section&gt; 保存一下，看看效果如下图。 4、页面的配置页面的配置是通过js完成的。 controls：是否显示左下角的控制键，默认为true progress：是否显示进度条，默认为true center：是否在居中显示，默认为true transition：为页之间的切换动画，默认为slide，即水平滑动，这里我们改成zoom缩放看看效果 12345678910&lt;script type="text/javascript"&gt; // 初始化页面 Reveal.initialize(&#123; controls: true, // 是否显示左下角的控制键，默认为true progress: true, // 是否显示进度条，默认为true center: true, // 是否在中间显示，默认为true // transition为页之间的切换动画，默认为slide，即水平滑动，这里我们改成zoom缩放试试 transition: 'zoom', // none/fade/slide(default)/convex/concave/zoom&#125;);&lt;/script&gt; 保存，用浏览器打开，效果如下。 5、小结以上就是本次教程的全部内容，如果认为默认的ppt样式不好看，你可以自己编写css代码对样式进行修改。关注公众号「嗜码」，后台回复reveal可以下载插件。另外，我自己做了一个关于jQuery介绍的ppt，也放在里面了，大家也可以去下载。 Be creative, build your own.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>reveal.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 学习路线分享]]></title>
    <url>%2F2018%2F05%2F28%2Fpython-learning%2F</url>
    <content type="text"><![CDATA[有位大一的学弟问我 python 如何去学，虽然我了解的也不深，但还是耐心的答复了他。 学弟，听说你想学 Python，不知道你现在的水平怎么样，首先值得肯定的是你有一颗爱学习、上进的心。比我大一的时候好多了，整天浑浑噩噩，直到大二才如梦方醒。作为一名大三 “老油条”，专业技术现在也算得上是过硬，对 Python 也有一定了解，我这里给你介绍一下学习的大致方向，希望可以少走点弯路。 像我们这个专业，一直期望着有人带你是不太可能的，自己要有自学的能力。包括分析和解决问题的能力，不要一碰到问题就问这问那，不会的首先独立思考，然后百度，百分之八十以上的问题都可以通过百度或者谷歌解决。 虽然不知道你 Python 学到了什么程度，如果是初学者，建议你首先在网上自学，不管是看视频还是看网页教程（这里推荐两个学习网站：慕课网以及菜鸟教程），把 Python 的基本语法弄懂，然后可以尝试着自己编写一些小程序甚至是小游戏。 如果这些你已经学会，那么就是 Python 进阶了。进阶这方面就我了解，涉及到 Python 的面向对象以及机器学习，你可以尝试着去网上购买一些书籍进行深入学习。面向对象涉及到设计模式，因此可以暂时不用理解，等你学了 Java 的面向对象编程就会慢慢领悟。 就目前而言，Python 算得上是机器学习最好的语言了。GitHub 有许多优秀的开源的机器学习的库，以及一些神经网络的算法，都可以直接拿来用。 虽然说，一些高级的东西可能会一时间难以接受理解，也很难应用。记住这句话：水到渠成。等你慢慢学习到了一定的高度，知识面开拓到了一定的范围，自然而然的便将这些东西融会贯通，灵活运用了。 为学习花点钱要舍得，专业书籍尽量去网上购买，避免在图书馆借。图书馆的书常年不更新，有些知识早就过时了，另外，买的书你也会更珍惜，更加促使你去阅读。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App 推荐 | 一个木函]]></title>
    <url>%2F2018%2F05%2F15%2Fapp-one-woodhan%2F</url>
    <content type="text"><![CDATA[今天推荐一款工具集应用，《一个木函》。应用功能强大，集成了几十种工具，而软件的体积只有 1M，十分轻巧，可以让我们卸载掉手机上不怎么使用但却必须要安装的 App。下面就一些常用的功能进行介绍。 取色器这个比较适合设计人员使用，当在编写前端 css 代码或者使用 photoshop 时，这个功能就派上用场了。通过点击拖动指示器，显示颜色的十六进制代码。 应用管理嗯，可以和软件管家说拜拜了。这个功能除了普通的卸载以及清除数据之外，还可以提取安装程序、应用图标、冻结程序等等。配套功能还有大文件清理，空文件夹清理等等。另外，如果要对系统自带应用进行管理，需要 root 权限。 带壳截图想让自己的截图有 b 格，可以试试这个。一般在应用市场上，一些 app 的介绍中使用的比较多。 二维码生成可以根据输入的内容或者连接生成二维码进行跳转。长按扫描试一试👇👇 尺子这个不经意间可能会用到，记得有这个功能就好。 一个木译调用的 Google 翻译的接口，应该是机翻里面最贴近实际的翻译了，支持 20 多种语言，功能挺强大的。但是如果是查单词，建议还是下一个词典 app。 加解密工具一些加解密的工具，例如 MD5 加密，或者摩斯密码的翻译等等。有兴趣的了解一下。 表情制作丰富的表情包，任意添加文字，同时可以修改文字颜色以及调整文字位置。妈妈再也不用担心我斗图了。 以上所介绍的只是软件的冰山一角，更多功能等着大家探索。关注公众号，后台回复一个木函下载最新版应用。]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期的一些感悟]]></title>
    <url>%2F2018%2F05%2F05%2Fthoughts-in-2018%2F</url>
    <content type="text"><![CDATA[近期的一些感悟今天同学给我发了一条qq消息，着实把我吓了一跳，还以为我写推送出事了。想着这两天也没写啥东西呀，写的东西也是干货，只不过昨天发了一条招聘信息，也不至于被查水表吧。 问清楚情况后，说是需要放进什么评估材料里。其实这里可能存在着一些误会，这个公众号一直是我一个人运营，我一直把他看成是自己的个人公众号，进行知识的分享，并非学院官方的公众号。 因此，后面我会更改公众号的名称，具体的名称还在想，但是内容依然是知识的分享，包括自己学习的总结，心路体会等等。 大学过的很快，转眼现在大四，虽然保研了，但还是选择先去实习，加入学长的创业团队，因为工作是迟要早面对的。只有在工作的时候，你才会发现你在课堂学的那些知识是多么的不堪一击，才会发现社会的优胜劣汰。 现在也有很多人会有工作、考研或者考公务员的疑惑，自己应该选择哪条路？班上也有同学选择了考研、考公务员或者是考雅思托福等等的，但有的同学明显是为了逃避找工作而做的选择。其实，无论是考研或者考其他的，最终都是要选择一份工作的，这是无法避免的，不要把考研当作借口，推脱自己身上迟早要面对的压力。 想到两个月前的场景，爱打游戏的同学放下了鼠标手机，开始变得紧张忧虑，开始拼命学习，开始刷题，谁也不想成为最后一个有没有工作也不考研的人。天道酬勤，经过了秋招的洗礼，一直努力的人拿到了满意的offer，临时抱佛脚的人依然在紧张。 两年时间，工作的同学可以在工作岗位积累丰富的实践经验，自己在研究生阶段也要更加努力，感谢那些一直默默支持我的人，希望一同进步。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 2018 总结]]></title>
    <url>%2F2018%2F04%2F29%2Fgoogle-io-content%2F</url>
    <content type="text"><![CDATA[Google I/O 2018大会于北京时间5月9日凌晨1点，在美国山景城Shoreline Amphitheatre(圆形剧场)举办。看了一下录播，字幕延迟，全程靠听，下面对上午的主会进行一个小结。（介绍按照时间大会顺序） Gboard（谷歌键盘） 新增莫斯电码的输入，主要方便于的残障人士的快速交流 Gmail （谷歌邮箱） 使用Material Design2，全新邮箱界面 邮箱输入自动补全 Photos （谷歌相册） AI自动整理图片 AI自动美化图片：增长曝光度，调节亮度等等 自动发送 文件图片可直接转PDF 老旧黑白照片可自动填充颜色 Assistant （谷歌助手） 6种不同的声音 持续对话，不用一直Hey，Google 加入13000儿童故事 AI智能导航 Android P （安卓9.0） 新增Dashboard，用于对App的使用进行时间管理 取消三段虚拟按键，使用类似与ios的手势操作 AI电池监控，减少30%的cpu唤醒，更省电 UI变化，状态栏、音量面板、通知栏、设置界面等 WAYMO （谷歌无人汽车） AI自动驾驶，适应各种路况 最后，很明显：All in AI.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App推荐 | Google Tasks]]></title>
    <url>%2F2018%2F04%2F29%2Fapp-google-tasks%2F</url>
    <content type="text"><![CDATA[前不久，Google推出了一款移动任务管理应用Google Task，在使用2天后，写一下使用感受，并与Google同类产品Keep进行一个对比。 首先欣赏几张官方的App截图 然后来看一下官方的介绍： 翻译：通过Google Tasks移动应用程序完成更多任务。随时随地管理，捕捉和编辑您的任务，以及在所有设备上同步的待办事项。与Gmail和Google日历的集成可帮助您更快地完成任务。 经过两天的使用，这里简单的说一下感受。首先就界面来说，Tasks采用Google一直提倡的极简风格。打开App，纯白的界面，加上一颗蓝色的圆腰按钮的点缀，整体的页面显得极其的简约。 熟悉Google的童鞋应该会发现，这个App的设计风格与之前Google一直所倡导的Material Design（以下简称为MD）风格还是有一些不一样。的确，在Android9.0（Android P）还没发布预览版之前，Google一直所采用的是一种扁平化的质感设计。 光效、表面质感、运动感是MD的核心。可以看到，这种风格大部分由矩形卡片组成，同时配色突出鲜明。但是在新出的Android P中，Google改进了这种设计，称之为MD2.0。其中大量地采用圆角设计，不论是通知面板、设置还是应用图标，全部使用圆形设计。 以后会更具详细的讲解Android P与之前Android版本的区别，这里便不再做赘述，下面继续介绍Tasks的功能。 首先点击醒目的蓝色按钮，建立一个新的任务。例如：Spring大作业。点击加号日历图标可以设置截止日期，这里设置4月30号完成，并点击save。 可以到任务详细页面里增添子任务，即不同时间段的该完成的任务，然后给各个子任务设置不同的时间期限，App就将会在不同的时间对你进行相应的提示，每天应该完成哪些任务。 以上就是Tasks的主要功能，操作十分的简便，用起来很流畅，App本身的体积只有不到5M，因此不会占用很大的内存空间。而且Google自家的应用，优化做的可是相当的好，不用担心会发生卡顿的现象，也不会一直留驻后台。（PS：与Google全家桶一同食用效果更佳） Google还有一款与Tasks功能相似的App，名字叫做Keep。但是这款App不仅仅针对任务，还包括一些灵光一现的想法，可以立即使用Keep记录下来。这个应用有时间还会单独给大家介绍。]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序学习路线]]></title>
    <url>%2F2018%2F04%2F24%2Fmp-learning%2F</url>
    <content type="text"><![CDATA[之前有学弟问到我小程序的学习路线，这里整理一下分享出来 小程序小程序的本质也是一个网页，只是它是通过微信内核来解析并加载渲染页面。如果只做静态的小程序的话，有html以及js的知识足够了，例如一些工具类的小程序，你只需要能够用js写出逻辑以及一些页面的css样式即可，例如天气类或者计算器之类的小程序。 所以可以先学习前端方面的知识，你应该大部分都掌握了。但还是要说的是，js一定要深入去了解学习，因为东西挺多而且杂，需要静下心来慢慢地学。 小程序进阶之后便是进阶的学习，你需要掌握一门服务器语言，php，c#，jsp（Java web）都行，学会之后，你可以干的事情就多了，小程序就不仅仅是一个静态的页面了，你可以进行前后台的交互，不过小程序不支持本地的服务器调试，因此你需要去购买云服务器，这部分博客上面都有大量的教程。动态的小程序就可以做出来，比如做一个表白墙。。。。🐕🐕🐕 其实微信开发最早的是微信公众号的开发，看似挺复杂，但是如果理解了，也就那么回事。举个简单的例子：移动公司的公众号里面有个查询流量的菜单，点击后返回消息显示当前流量余额。其中的过程就是，点击菜单，然后触发了一个事件，其实就是发生一个请求到后台的服务器，这个请求中的参数就是手机号，服务器接收到请求，通过手机号查询到相关的信息。因此，所谓的公众号开发其实就是服务器端的开发，属于后台，一般使用php或者Java web。另外还有一个就是微信内网页开发，其实也是和小程序差不多，这里自己去了解吧。 推荐书单至于说书单，倒是没有特别的相关书要推荐，教程书真的是一大堆，小程序看文档就好了，后台相关的书可以买几本。一般在当当上买，买的时候看一下同类书的销量排行，选前几名的买就行了😁😁。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号关联小程序教程]]></title>
    <url>%2F2018%2F04%2F20%2Fofficial-account-link-mp%2F</url>
    <content type="text"><![CDATA[进入公众号后台，点击小程序管理 点击添加 选择关联小程序，然后扫描二维码验证 输入对应的APPID（wxfbe916702aa06f6a），然后点击发送邀请。 小程序的开发者会确认邀请，这时候公众号与小程序的关联就完成了。 ps:欢迎关联cool体测小程序（appid：wxfbe916702aa06f6a）]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle11g 64位安装教程以及安装过程中可能遇到的问题]]></title>
    <url>%2F2018%2F03%2F30%2Foracle-setup-tutorial%2F</url>
    <content type="text"><![CDATA[1、安装准备下载官网的oracle安装程序，有两个压缩包。 选中这两个压缩包，点击解压到当前文件夹，两个压缩包同时解压成一个名叫database的文件夹。这里特别注意，两个压缩包要同时选中，解压成一个文件，不然可能会安装失败。 解压好后出现一个database文件夹，大小为2.13GB。 点进去，找到setup.exe，右击，以管理员身份运行，开始安装。 这里需要检查，等待一会。 检查之后如果出现环境不满足最低要求的警告（如下图） 先取消安装，我们需要修改文件database---&gt;stage---&gt;cvu---&gt;cvu_prereq.xml中的内容。右键用编辑器打开，在此处加上如下代码。 12345678&lt;OPERATING_SYSTEM RELEASE="6.2"&gt; &lt;VERSION VALUE="3"/&gt; &lt;ARCHITECTURE VALUE="64-bit"/&gt; &lt;NAME VALUE="Windows 10"/&gt; &lt;ENV_VAR_LIST&gt; &lt;ENV_VAR NAME="PATH" MAX_LENGTH="1023" /&gt; &lt;/ENV_VAR_LIST&gt;&lt;/OPERATING_SYSTEM&gt; 2、开始安装将接收安全更新的选项取消，可选操作。点击下一步 可以无视警告，点击是。 选择第一项，创建和配置数据库，并点击下一步。 修改安装目录，千万注意，这里的目录不能出现中文字符。其他的选项默认就行，另外还需要输入管理员的密码。尽量设置简单一点的，容易记住。密码一定要记住!!! 出现密码不符合标准不要紧，这是由于oracl为了安全，这里我们直接继续。然后系统会检查条件。如果失败了，点击全部忽略，不影响后面的安装。 点击完成就开始安装了 后面的都直接默认就行了，一定要记住输入的密码。 3.检查是否安装成功。在开始菜单里找到Oracle文件夹，然后点击这个orcl 会弹出一个网页，需要输入账号密码，以管理员身份登录，账号为sys或者system，密码是自己设置的，如果忘了可以通过命令重置。 登录后进入控制台，如果界面是这样子，就是成功了。 4.安装过程中可能遇到的问题 安装到42%的时候出现未找到文件wfmlrsvcapp.ear报错。 12345解决办法：点击中止安装，然后将win64_11gR2_database_2of2文件database/stage/Components/下的几个文件copy到之前解压的database文件夹中相同目录下，然后重新安装，不用删任何东西，重新安装会覆盖之前的安装。 安装到98%时出现注册OCX时出现OLE初始化错误或OCX加载错误。 解决办法：点击中止安装，错误原因是安装路径中有中文字符，重新安装，修改一下路径就行了。 以上就是Oracle11g 64位的安装教程，欢迎各位对问题进行补充。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序题智能批改系统需求分析]]></title>
    <url>%2F2018%2F03%2F17%2Fpoj-analyse%2F</url>
    <content type="text"><![CDATA[1 需求分析1.1 系统简介在计算机教育领域，尤其是程序设计类课程，教学内容基本上是理论与实践相结合。对于的传统的手动批改源代码和程序的方式通常会耗费教师巨大的精力，也难以保证结果公正性，因此程序题自动批改系统备受关注。目前应用较为广泛的的程序自动批改系统是ACM/ICMP的Online Judge程序批改系统，但是在多数的程序设计类课程中，ACM/ICMP并不适用。ACM/ICMP系统只能够处理标准的输入输出程序，并且给出对或错两种结果，无法像手工批改一样，对各方面进行打分，同时给出具体的分数以及错误原因。 因此，设计一个程序题智能批改系统，采用提交-反馈的模式，让学生在离开老师的情况下，可以自己编写程序并交给系统进行批改，同时教师可在后台查看学生的学习情况，并予以反馈。这不仅提高了学生编写程序的积极性，也驱动学生去深入学习编程，大大减轻了教师的工作量。 1.2 需求说明程序题智能批改系统可用于让学生在没有老师的监督下，独立编写程序并通过系统提交给后台。教师在后台可查看学生的学习情况，并针对不同学生的答题情况予以反馈。主要需求如下： 学生可以在线编程，并支持本地调试 学生可以将编写好的代码提交到服务器端，并查询自己的成绩 教师可以题库进行管理，例如：增加题目、修改答案等等 教师可以对学生成绩进行管理，并可查看成绩分析报告 教师可以在线批改学生代码，并予以反馈 管理员可以对学生及教师信息进行管理 1.3 用例分析1.3.1 用例与角色学生： 查询相关个人基本信息 查询成绩 在线编程答题 提交代码 测试代码 下载代码 问题反馈 教师： 题库管理 查询个人基本信息 在线批改 生成成绩分析报告 代码安全检测 成绩管理 管理员： 管理学生基本信息 管理教师基本信息 1.3.2 用例图 1.3.3 用例描述 用例名称：成绩查询 描述：学生查询个人成绩信息 标识符：UC01 角色：学生 前置条件：学生成功登录系统 主事件流： 1.学生点击个人信息连接，跳转到个人信息页面 2.点击题目，查询所得成绩 3.用例结束 其他事件流： 1.学生未答题，未显示分数 用例名称：在线编程答题 描述：学生进行在线编程答题 标识符：UC02 角色：学生 前置条件：学生成功登录系统并点击题目 主事件流： 1.学生选择题目类型 2.学生点击题目链接 3.跳转到程序编写界面进行编程 4.下载代码进行本地调试 5.用例结束 其他事件流： 后置事件流：学生点击“保存”按钮 用例名称：测试代码 描述：学生对编写好的代码进行测试 标识符：UC03 角色：学生 前置条件：学生编写好代码并点击“测试”按钮 主事件流：1.学生编写代码 2.学生点击“测试按钮” 3.系统检查代码的安全性 4.返回测试结果 5.用例结束 其他事件流： 1.学生关闭窗口，提示“保存代码” 2.学生编写的代码运行异常，警告“疑似病毒” 后置事件流：学生点击“提交”按钮 用例名称：提交代码 描述：学生对测试好的代码进行提交 标识符：UC04 角色：学生 前置条件：学生编写好代码并点击“提交”按钮 主事件流：1.学生编写代码 2.代码通过安全测试 3.学生点击“提交按钮” 4.用例结束 其他事件流： 1.学生代码安全测试未通过，提交按钮禁用 后置事件流：无 用例名称：下载代码 描述：学生下载教师提供的参考代码 标识符：UC05 角色：学生 前置条件：教师上传参考代码 主事件流：1.学生选择题目 2.点击参考代码链接进行下载 3.用例结束 其他事件流：无 后置事件流：无 用例名称：问题反馈 描述：学生对题目的疑惑在留言中反馈 标识符：UC06 角色：学生 前置条件：无 主事件流：1.学生输入问题内容 2.学生点击提交按钮 3.用例结束 其他事件流： 1.输入的内容为空，提示“输入的内容为空” 后置事件流： 1.管理员审核通过，反馈显示 用例名称：题库管理 描述：教师对编程题目进行管理 标识符：UC07 角色：教师 前置条件：教师成功登录系统 主事件流：1.教师点击题库管理链接 2.教师可以增加或批量导入题目，并设置答案及上传参考代码 3.教师可以批量删除题目 4.教师可以修改题目信息，可以修改题目答案 5.教师可以对所有题目进行条件查询或者模糊查询 6.教师点击保存按钮，完成对题库的管理操作 7.用例结束 其他事件流： 1.关闭页面时，教师批量导入未点击保存按钮，提醒用户保存 2.查询条件为空，查询所有题目 后置事件流： 1.所有增加或者修改的题目信息均保存到数据库中，学生看到新的题目信息 用例名称：在线批改 描述：教师在线对学生编写的代码进行批改并予以评价反馈 标识符：UC08 角色：教师 前置条件：教师成功登录系统 主事件流：1.教师点击在线批改按钮，系统自动打分。 2.教师可以点击查看某个学生的具体答题情况，并予以评价 3.教师可对学生所提疑问进行在线解答 4.教师可以导出学生所写的代码 5.用例结束 其他事件流： 1.代码安全检测未通过，程序不予以执行 后置事件流： 1.题目的得分信息保存到数据库中，学生可看到自己的成绩 用例名称：成绩管理 描述：教师对学生的成绩信息进行管理 标识符：UC09 角色：教师 前置条件：教师成功登录系统 主事件流：1.教师点击学生成绩信息管理按钮 2.教师可以修改学生的成绩信息 3.教师可以删除学生的成绩信息 4.教师可以按条件查询学生的成绩信息 5.教师点击保存，完成对学生信息管理的操作 6.用例结束 其他事件流： 1.查询条件为空，查询所有的学生信息 后置事件流： 1.修改的成绩信息保存到数据库中，学生可看到自己修改后的成绩 用例名称：生成成绩分析报告 描述：生成学生的成绩分析报告 标识符：UC10 角色：教师 前置条件：教师成功登录系统，点击了成绩管理按钮 主事件流：1.教师点击学生成绩信息管理按钮 2.教师点击了生成学生成绩报告 3.教师可以按不同条件对成绩进行统计分析 4.教师可以下载生成的分析报告 5.用例结束 其他事件流：无 后置事件流：无 用例名称：学生信息管理 描述：管理员对学生信息进行管理操作 标识符：UC11 角色：系统管理员 前置条件：管理员成功登录系统，并点击学生信息管理 主事件流：1.管理员点击学生信息管理 2.管理员可以批量导入学生信息 3.管理员可以删除学生信息 4.管理员可以修改学生信息 5.管理员可以进行条件查询或者模糊查询 6.管理员点击保存完成对学生信息管理的操作 7.用例结束 其他事件流：1.点击保存，学生信息为空或者不符合要求，提示“学生信息不符合要求” 后置事件流：1.对于新增的学生，学生可以通过账号密码登录系统 用例名称：教师信息管理 描述：管理员对教师信息进行管理操作 标识符：UC12 角色：系统管理员 前置条件：管理员成功登录系统，并点击教师信息管理 主事件流：1.管理员点击教师信息管理 2.管理员可以批量导入教师信息 3.管理员可以删除教师信息 4.管理员可以修改教师信息 5.管理员可以进行条件查询或者模糊查询 6.管理员点击保存完成对教师信息管理的操作 7.用例结束 其他事件流：1.点击保存，教师信息为空或者不符合要求，提示“学生信息不符合要求” 后置事件流：1.对于新增的教师，教师可以通过账号密码登录系统 2 系统设计2.1 实体关系建模 &amp;实体关系模型直接从现实世界中抽象出实体类型和实体间联系，建立实体关系模型是系统设计的第一步。就本系统而言，「学生」(Student)、「教师」(Teacher)、「管理员」(Admin)、「问题」(Question)、「提交」(Submission)、「通知」(Notification)、「笔记」(Note)、「附件」(Enclosure)、「成绩」(Grade)以及「留言」(Message)都是经常出现的名词，它们也都是从需求描述中识别出来的「实体」。通过建立实体之间相应的关系，从而得到实体关系模型，以完成设计需求。 程序题智能批改系统是一个小型的在线编程评判系统，系统共11个实体类型，下图显示了它们之间的所有模型和关系。 2.2 数据库设计本系统数据库使用MySQL5.0，一种关系数据库管理系统，数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。本系统数据库中数据存放于10张表中，所有“id”键字段都是Java类型的Integer。数据库结构图如下图。 2.3 界面设计2.3.1 页面跳转关系 系统首页展示的是教师发布的题目、推荐文章以及学生发布的笔记 学生登录进入学生后台，可查询自己的成绩、在线答题以及管理笔记等 教师登录进入后台可管理题库、发布通知、发布文章以及生成成绩分析报告 管理员登录进入后台可以管理学生以及老师的信息 页面跳转图分别如下图: 2.3.1 页面设计 本人对下述需求进行了代码实现，使用ssm框架。涉及到Java的动态编译方面的知识，另外，评分通过获取后台数据库中的测试用例，动态执用例进行评分。 需要源码的可以扫码关注公众号『嗜码』，回复「程序题批改系统」即可获取源码，源码使用的 spring mvc 框架。]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
        <tag>在线编程</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开源组件库]]></title>
    <url>%2F2018%2F01%2F25%2Fmp-conponent-collection%2F</url>
    <content type="text"><![CDATA[推荐3个小程序开源组件库在进行小程序开发时，经常会遇到编写组件方面的阻碍，这让我们花费大量的时间在页面以及 CSS 样式编写上。因此可以使用开源组件库，有些复杂的组件可以直接拿来使用，节省开发时间，避免重复造轮子。 Vant 由「有赞」团队维护的开源项目，目前 GitHub 上有 8057 颗 ⭐。Vant 提供了一整套 UI 基础组件和业务组件，通过 Vant 可以快速搭建出风格统一的页面，提升开发效率。除了一些常用的 UI 组件，Vant 还提供了一些适用于商城小程序的业务组件，例如省市区选择、商品卡片、商品导航等，帮助开发者快速搭建一些商城类的小程序。 iView一套高质量的微信小程序 UI 组件库，目前 GitHub 上有 3590 颗 ⭐。与 Vant 相比，iView 的交互组件更多，更能满足一些开发者的特殊需求。另外，对新手很友好，事无巨细的文档、友好的 API 和完整的示例，几分钟就可以上手。 ColorIUIColor UI 是一个纯 CSS 库，只需要将 CSS 引入即可，配置方便。相比于同类小程序组件库，ColorUI更注重于视觉交互！ 另外，设计非常具有现代感。组件颜色清新，动画活跃，更加注重于视觉交互。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记（六）—— 事件]]></title>
    <url>%2F2017%2F11%2F17%2Fjavascript-learning-6%2F</url>
    <content type="text"><![CDATA[Javascript 与 HTML 之间的交互是通过事件来实现的。平时用多了JQuery，JavaScript 往往会变得生疏，有时候会不是很理解某些事件的写法，这里将学习过程做个记录。 DOM0 级事件事件处理的传统方式，也就是 DOM0 级事件模型，通过将一个函数赋值给一个事件处理程序属性，来实现事件的处理逻辑。这种方式十分简单，并且所有浏览器都适用。例如下面代码： 1234varbutton = document.getElementById("buttonId");button.onclick = function(e) &#123; alert("button"); // 'button'&#125;； 上面代码首先通过 id 获得了一个按钮的对象，然后将一个匿名函数赋值给对象的 onclick 属性，这样当我们点击按钮时，便会触发 function 里面的代码。同时，会传入一个参数 event，这个参数里包含了事件相关的信息，例如：点击的坐标，触发改事件的元素等等。 由于这种方式是对属性进行赋值，因此同一个元素后一次的相同事件会覆盖前一次，例如下面代码： 1234567var button = document.getElementById("buttonId");button.onclick = function(e) &#123; alert("1")&#125;;button.onclick = function(e) &#123; alert("2");&#125;; 结果输出 2，因为后一次的赋值覆盖了前一次。 因此，如果我们要注销事件绑定，只需要将属性值赋为 null 1button.onclick = null; 和这种方式相同的就是将函数名称写在 html 页面中，自定义一个函数，并将其赋值给 onclick 属性例如如下代码： 1&lt;button onclick="clickFunction()"&gt;&lt;/button&gt; 这种方式的不同之处在于它不会给函数传入 event 参数 DOM2 级事件DOM2 级事件处理程序和 DOM0 的不同之处在于，DOM2 级事件支持事件流的响应，以及同一个元素支持多个相同的事件。因此，学习 DOM2 事件前先看看事件流。 事件流在网上看到一句这样的话来形容事件流，感觉十分的形象：在一张纸上有一组同心圆，如果你把手指放到圆心上，那么你的手指指向的不是一个圆，而是纸上所有的圆。比如我们点击了页面中的某一个按钮，我们不仅点击了按钮，还点击了包含按钮的容器，甚至还点击了整个页面窗口。 所谓事件流就是接受事件的顺序。DOM2 级事件中规定事件流包括三个阶段：捕获阶段、目标阶段、冒泡阶段。 看一张图，便能很好的理解事件流。 如图所示，当一个事件触发时，最先得到消息的是 Document，然后是 HTML， 一层一层，找到触发事件的元素，这个过程属于事件捕获阶段。之后，便是对事件处理的逻辑，这是目标阶段。最后，事件会向上传播，通知上层元素事件处理完毕，这是事件冒泡阶段。 DOM2 级事件方式DOM2 级事件定义了 addEventListener 和 removeEventListener 两个方法，用于为指定元素添加事件绑定和删除事件绑定。例如下面代码： 1234varbutton = document.getElementById("buttonId");button.addEventListener("click", function (e) &#123; alert("clicked");&#125;, false); 可以看到，addEventListener 函数有三个参数，第一个为事件的名字，第二个为事件处理程序，第三个为 bool 类型。如果为 true，表示在捕获阶段触发，如果是 false，表示在冒泡阶段触发。 通过下面例子，来理解一些这个函数： 123&lt;div id="outer"&gt; &lt;div id="inner";"&gt; 内部 DIV&lt;/div&gt;&lt;/div&gt; 这里定义了两个 div，id 分别为 outer 和 inner，效果如图： 然后为每个 div 添加事件 1234567891011var inner = document.getElementById("inner");var outer = document.getElementById("outer");inner.addEventListener("onclick", function (e) &#123; alert("1");&#125;,true);outer.addEventListener("onclick", function (e) &#123; alert("2");&#125;, true);inner.addEventListener("onclick", function (e) &#123; alert("3");&#125;, false); 之前提到了，DOM2 级别事件中同一个元素支持多个相同的事件，上面的代码为 inner 设置了两个点击事件，分别在捕获阶段和冒泡阶段响应。outer 元素的点击事件在捕获阶段响应。 点击外部的 outer，只弹出 2，这是因为事件流没有传播到内部。 点击内部的 inner，弹出的顺序为 2，1，3。因为 outer 在外层，且为捕获事件，因此会比 inner 先响应事件，而 inner 由添加了冒泡事件 3，因此在事件冒泡阶段响应。 小结一般情况下，只需在最外层 dom 元素注册一次事件，然后通过捕获、冒泡机制去找到真正触发事件的 dom 元素，最后根据触发事件的 dom 元素提供的信息去调用回调。JQuery 中事件就是这样封装实现的，调用非常的方便。 事件的学习远不如此，在学习微信小程序中，会出现各种事件的处理，我们要理解原生 JavaScript 中的原理，才能学好其他的一些东西。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记（五）—— 闭包（closure）]]></title>
    <url>%2F2017%2F10%2F07%2Fjavascript-learning-5%2F</url>
    <content type="text"><![CDATA[今天学习了 JavaScript 的闭包，这里做一个自己理解的分享。 闭包是 JavaScript 中的一个难点，同样也是重点，很多的高级应用都需要使用闭包来实现。 变量的作用域要理解 JavaScript 中的闭包，就要先理解作用域。首先，我们要知道，JavaScript 没有块级作用域，这是什么意思？我们来看下面的代码： 1234567if (true) &#123; var name = 'zmy'; alert(name); // zmy&#125;alert(name); // zmy 结果输出了两次 ‘zmy’ 可以看到，在 if 语句块里声明的 name 变量，在语句块外面依然能够访问。这是因为 JavaScript 不存在块级作用域，在块中定义的变量，快外依然能够访问到。 在看看 Java 语句代码： 123456789class Test &#123; public static void main(String[] args) &#123; if (true) &#123; String name = "zmy"; System.out.print(name); &#125; System.out.print(name); &#125;&#125; 运行代码，结果显示报错，找不到符号 name。 这是因为 Java 有块级作用域，变量只会存在当前的块级作用域中，外部不能直接访问。 JavaScript 中的作用域相对于其他的块级语言来说比较特殊，它虽然没有块级作用域，但是存在函数作用域。这是什么意思呢，来看一下下面的这段代码： 12345function sayPersonName() &#123; var personName ='zmy';&#125;sayPersonName();alert(personName); // error 运行结果如下报错，显示 person Name 未定义。这是因为 JavaScript 中存在函数作用域，函数外部不能访问函数内部的变量。 这里值得注意的是，函数重点变量名需要关键词 var，如无此关键词，则默认为 全局变量，因此下面的代码是能够访问的： 12345function sayPersonName() &#123; personName = 'zmy';&#125;sayPersonName();alert(personName); // 'zmy' 闭包由上诉阐述引出了一个问题，我们如何才能够访问到函数里的变量？前面已经证明，我们不能够直接访问到变量，这样会引发错误。因此，我们可以使用闭包。 首先理解一下闭包的概念：是指有权访问另一个函数作用域中的变量的函数。 说的直白一点，闭包其实就是一个函数，而常见的创建闭包的方式就是在函数内部创建另一个函数。例如下面代码： 12345678function outerFunc() &#123; var n = 1; function innerFunc() &#123; alert(n); // 1 &#125; innerFunc();&#125;outerFunc(); 上面代码在 outerFunc () 中声明了一个 innerFunc () 函数以及一个变量，然后调用外层函数，输出了 n。 因此可以看出，内存函数能够访问外层函数变量。但反过来不行，内部函数变量对外部函数不可见。 这就是 Javascript 语言特有的 “链式作用域” 结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然内层函数能够返回外层函数的变量，那我们如果把 innerFunc () 作为返回值，上面的问题就可以解决了。 例如下面代码： 123456789function outerFunc() &#123; var n = 1; function innerFunc() &#123; alert(n); // 1 &#125; return innerFunc; &#125;var result = outerFunc();result(); // 1 可以看到，上面的代码将 innerFunc 作为 outerFunc () 的返回值，因此变量 result 变成一个函数，即 innerFunc ()。通过调用 result () 就可以访问 n 了。 以上是个人对闭包对理解，望多多指教！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 学习笔记 (四)—— 面向对象]]></title>
    <url>%2F2017%2F10%2F05%2Fjavascript-learning-4%2F</url>
    <content type="text"><![CDATA[前端 Javascript 的开发主要有两种方式：向对象编程（OOP）与函式编程（FP），面向对象有助于是将松散的 JS 代码进行整合，便于后期的维护，是让我们的代码适应更多的业务逻辑。 理解对象Javascript 中的对象与其他的基于类语言中的对象有所不同。Javascript 中没有没有类的概念，对象通过引用类型创建，引用类型可以是原生的 JavaScript 类型，比如 Object、Date、Array 等等，也可以是我们自己定义的类型。 ECMA-262 (规范版本号) 把 JavaScript 对象定义为：无序点到属性的集合，其属性可以包含基本值、对象或者函数。严格来说，就相当于说对象是一组没有特定顺序的值。对象中的每个属性或者方法都有一个名字，而每个名字都映射到一个值。下面通过两个例子理解一下这个概念。 创建自定义对象的最简单的方式就是创建一个 Object 的实例，即 new 一个 Object 的构造方法，然后在为它添加相应的属性和方法。 第二种方法为对象字面量（literal）语法创建： 属性特性在 Java 中，通过使用 private 关键字，使得有些或者属性或者我们不能直接访问，需要通过某些特定的方法进行访问。JavaScript 中没有提供这种关键字，但是可以通过改变属性特性将特定的属性或者方法隐藏。也可把它称为属性的属性。 下表列出了 JavaScript 中属性的属性以及其含义： 在 JavaScript 中，必须使用 Object.defineProperty () 方法对默认的特性进行修改。 通过下面的例子来理解一些这几个特性。 上面的代码用字面量方法创建了一个对象实例 person，对象的属性中有 name、age。通过调用 Obejct.defineProperty () 方法，对 name 属性：writable、congfigurable 两个特性进行修改。 我们再看一下属性的 set 以及 get 特性： 这里创建了一个 time 的对象，并给它定义两个默认的属性：_month, edition。_year 前面的下划线是一种标记，用于表示只能通过对象方法访问的属性。通过 Obejct.defineProperty () 创建 month 属性，并包含了 get 和 set 函数。通过修改 month 属性值，year 属性值也相应的改变。 虽然我们平时基本上不会用到这个，但对我们理解 JavaScript 对象非常有用！ 创建对象方式前面说到，创建对象的两种方式，但是当我们需要创建多个对象的时候，就会产生大量的重复代码。因此考虑用更好的方法去创建对象。 工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，即我们创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 例如下面的代码： 上面的方法虽然解决了创建多个相似对象的问题，但是这种方法没有解决对象识别的问题，即如何知道一个对象的类型。 因此，出现了一种构造函数模式。 构造函数模式类似我们创建的 Object 对象的实例，使用 new 关键字，并调用 Object 的构造函数。我们也可以自定义构造函数，并且自定义对象的类型和方法。例如我们将上面代码重写成构造函数模式： 上面创建了一个名为 Person 的函数，这里函数用首字母大写用于区分其他一般函数，当然小写也是没有任何问题的。然后通过 new 关键字来创建了两个 Person 对象的实例，通过 instanceof 检测 person1 的类型发现它既是 Person 的实例，又是 Object 的实例，这是因为所有的对象均继承自 Object。 自定义构造函数意味着我们可以将他的实例标识为一种特定的类型，这就是构造函数要优于工程模式的地方。但是，自定义构造函数的方法仍然存在缺点，那就是每个对象中的属性和方法在每个实例中都要重新创建一遍。在前面的例子中，person1 和 person2 的属性和方法其实是不一样的，我们通过比较以下二者的方法可以看出，结果返回 false。 因此，两个实例都是 Perosn 的对象，完成同样的任务，却为其创建了不同的及方法，这是没有必要的。可以通过原型模式来解决这个问题。 原型模式JavaScript 中每个函数都有一个 prototype (原型) 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含所有实例共享的属性和方法。这是什么意思？我们通过下面的代码理解一下： 我们通过在控制台打印结果 String 类型以及 Date 类型的原型属性，结果返回了两种类型的方法。 因此，我们可以不用在构造函数中定义对象的实例信息，而是将这些信息直接添加到原型对象中，使得所有的对象实例可以共享它所包含的属性和方法。如下面的这个例子： 我们来看一张图，可更好的理解原型对象。 这张图展示了这个例子各个对象之间的关系。当创建一个构造函数时，构造函数有一个 prototype 的指针，指向 Person 的原型对象，这个原型对象中就包含了一下属性和方法。原型对象中有一个名为 constructor 的属性，这是一个指向 prototype 属性所在函数的指针，我们打印一下 Person.prototype，在控制台可以发现他们是一层一层的包裹，即互相指向对方。 我们可以通过对像实例访问保存在原型中的值，但是不能通过对象实例重写原型中的值，例如： 在这个例子中，person1 的 name 被一个新的值屏蔽。当需要读取某属性值时，会先在实例上搜索属性，如果没有找到，便会到原型对象中去寻找。 可以通过 delete 操作符删除实例属性。 原型中所有的属性是被很多实例共享，这种共享对于函数非常合适。然和对于包含引用类型值的属性，比如包含属性值为一个数组，就会出现问题，这里就不细说。于是便有了更多的模式：比如组合构造函数模式和原型模式、动态原型模式、寄生（parasitic）构造函数等等。 继承JavaScript 中实现继承的主要方法是利用原型链，让一个引用类型继承另一个引用类型的属性和方法。刚刚说到：每个函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例包含一个指向原型对象的内部指针。如果我们让原型对象包含另一个类型的实例，即原型对象中还包含指向另一个原型对象的指针？结果会怎么样呢？ 来看一下这个例子： 这里运用原型模式创建了一个 Son 对象，对象中包含一个 sonName 属性以及一个 saySonName 方法，并创建了一个实例 son，传入了一个 son 字符串。 此时，Son 构造函数与原型在之间的关系我们可以用下面的图来表示： 然后，用同样的方法穿件一个 Father 对象，对象中包含一个 fatherName 属性以及一个 sayFatherName 方法。代码如图所示： Father 构造函数的原型关系如下图: 此时，我们让 Son 的原型指针指向 Father 的原型对象，并打印前后 Son 的原型对象。 代码如下： 可以看到，第一行打印的是 Son 的原型对象，第三行打印的是 Father 的构造函数，因此此时的原型关系图如下： 现在分别在实例化 Son，并使得 son 调用父类型的 sayFatherName 的函数，结果输出 father。 Son.Prototype 被当作 Fanter 的一个实例，因此有一个 prototype 的指针指向 Father 的原型，因此构成了一条原型链，即可看作类型的继承。 最后，我们打印原型的时候发现有一些熟悉的函数，是的，那就是 Object 的内置函数，所有类型均继承自 Object.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记 (三)——引用类型：Object、Array、Date]]></title>
    <url>%2F2017%2F09%2F30%2Fjavascript-learning-3%2F</url>
    <content type="text"><![CDATA[Object 类型引用类型是一种数据结构，在 Java 中，被称为类。在 JavaScript 中，被称为对象定义。 创建 Object 实例有两种方法。第一种是使用 new 操作符后跟 Object 构造函数，和 Java 语言相似。 另一种方式为使用对象字面量表示法： 这种方法创建了和第一种方法同样的对象。另外，对象字面量也是向传递大量可选参数的首选方式。例如： Array 类型JavaScript 中数组类型为最常见的类型之一，其大小可以动态调整。 声明数组同样有两种方式。第一种使用 new 操作符。 另外也可以通过字面量声明数组对象： JavaScript 中为数组提供了一些函数，tostring() 方法将数组中的数据以字符串形式返回，项与项之间使用逗号分隔，例： Join () 函数，可使用不同分隔符将数组转换为字符串，若 join () 函数中不传入参数，则默认使用逗号分隔。 Javascrip 还提供了 push ()、pop () 和 shift () 方法，可分别实现类似栈和队列行为。排序方法有 sort()，reverse() 等。还有一些操作方法和 Java 相似。 Date 对象使用 new 操作符和 Date 构造函数创建一个日期对象。 另外还有一些操作日期的函数，例：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记 (二)——变量、作用域、函数和内存]]></title>
    <url>%2F2017%2F09%2F29%2Fjavascript-learning-2%2F</url>
    <content type="text"><![CDATA[1、Javascript 中变量可能包含两种不同数据类型的值：基本类型的值和引用类型的值。 对于引用类型的值，可以为其添加属性和方法，也可以改变其属性和方法，例如： 但是，不能对基本类型的值添加属性，例如： 2、JavaScript 没有块级作用域。对于有块级作用域的语言，例如 C、C++、Java 中，新声明的变量只存在与当前块级作用域中，块级语句执行完毕后变量即会销毁。例如 (Java)： 运行结果报错，显示 i 未定义： 而在 JavaScript 中，没有块级作用域，变量不会被立即销毁，例如 (JavaScript)： 3、JavaScript 函数的参数和大多数其他语言中的参数有所不同。JavaScript 函数不介意传递进来多少个参数，也不介意参数的数据类型。即使定义的参数只接受两个参数，在调用函数的时候也未必需要传递两个参数。可以选择传递一个、三个甚至不传递。 JavaScript 中的参数在内部使用一个数组来定义，函数接收的始终是一个数组。在函数体内通过 arguments 对象访问参数数组，例如： 4、JavaScript 最常用的垃圾收集方式为标记清除，通过对变量的标记进行判断，并对其采取相应的策略。 为确保暂用较少的内存可以使得页面获得更好的性能，通常需要对变量进行解除引用，即将其值设置为 null。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记 (一)——值、类型和运算符]]></title>
    <url>%2F2017%2F09%2F28%2Fjavascript-learning-1%2F</url>
    <content type="text"><![CDATA[1、JavaScript 中包含 6 中基本的值类型：数字 (number)、字符串 (String)、布尔值 (boolean)、对象 (object)、函数 (function) 和未定义类型 (undefined)。 使用 typeof 操作符返回数据类型。 2、JavaScript 中有三个特殊的值，他们虽然是数字，但是和一般的数字看起来不太一样。它们分别为 Infinity、-Infinity 和 NaN。NaN 虽然是数字类型的值，但是用其表示 “非数值”。 例: 1/0-----&gt;Infinity;-1/0-------&gt;-Infinity; 字符串除一个数字得到 NaN。 3、在 JavaScript 中，不是所有的值都等于它本身，只有一个值不等于其自身，那就是 NaN。NaN == NaN —-&gt; false 4、当运算符作用在错误的类型的值上时，JavaScript 会自动将其转换成自己期望的类型。例如 8*null -----&gt; 0，&quot;5&quot; - 1 -----&gt; 4，“5”+ 1-----&gt;51。 5、如果不希望在比较的时候进行自动的类型转换，可以使用 === 或者！==。 6、逻辑运算符的短路特性。先对左侧值进行判断，若满足，则忽略右侧，即不计算右侧表达式。例：true || X，直接返回 true，不会计算 x，false &amp;&amp; X 也是同样道理。下图例子中可以看到 x 的值始终为 1，没有改变。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
